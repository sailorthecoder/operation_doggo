"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/search",{

/***/ "./src/components/Slider.tsx":
/*!***********************************!*\
  !*** ./src/components/Slider.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-range */ \"./node_modules/react-range/lib/index.js\");\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_range__WEBPACK_IMPORTED_MODULE_1__);\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\nconst Slider = ({\n  min,\n  max,\n  values,\n  onChange\n}) => {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_range__WEBPACK_IMPORTED_MODULE_1__.Range, {\n    step: 1,\n    min: min,\n    max: max,\n    values: values,\n    onChange: onChange,\n    renderTrack: ({\n      props,\n      children\n    }) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", _extends({}, props, {\n      style: { ...props.style,\n        height: \"6px\",\n        width: \"100%\",\n        backgroundColor: \"#ccc\"\n      }\n    }), children),\n    renderThumb: ({\n      props\n    }) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", _extends({}, props, {\n      style: { ...props.style,\n        height: \"20px\",\n        width: \"20px\",\n        backgroundColor: \"#fff\",\n        border: \"1px solid #ccc\",\n        borderRadius: \"50%\",\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        boxShadow: \"0px 2px 6px #aaa\"\n      }\n    }))\n  });\n};\n\n_c = Slider;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Slider);\n\nvar _c;\n\n$RefreshReg$(_c, \"Slider\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9TbGlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUdBLE1BQU1FLE1BQTZCLEdBQUcsQ0FBQztFQUFFQyxHQUFGO0VBQU9DLEdBQVA7RUFBWUMsTUFBWjtFQUFvQkM7QUFBcEIsQ0FBRCxLQUFvQztFQUN4RSxvQkFDRSwyREFBQyw4Q0FBRDtJQUNFLElBQUksRUFBRSxDQURSO0lBRUUsR0FBRyxFQUFFSCxHQUZQO0lBR0UsR0FBRyxFQUFFQyxHQUhQO0lBSUUsTUFBTSxFQUFFQyxNQUpWO0lBS0UsUUFBUSxFQUFFQyxRQUxaO0lBTUUsV0FBVyxFQUFFLENBQUM7TUFBRUMsS0FBRjtNQUFTQztJQUFULENBQUQsa0JBQ1gsK0VBQ01ELEtBRE47TUFFRSxLQUFLLEVBQUUsRUFDTCxHQUFHQSxLQUFLLENBQUNFLEtBREo7UUFFTEMsTUFBTSxFQUFFLEtBRkg7UUFHTEMsS0FBSyxFQUFFLE1BSEY7UUFJTEMsZUFBZSxFQUFFO01BSlo7SUFGVCxJQVNHSixRQVRILENBUEo7SUFtQkUsV0FBVyxFQUFFLENBQUM7TUFBRUQ7SUFBRixDQUFELGtCQUNYLCtFQUNNQSxLQUROO01BRUUsS0FBSyxFQUFFLEVBQ0wsR0FBR0EsS0FBSyxDQUFDRSxLQURKO1FBRUxDLE1BQU0sRUFBRSxNQUZIO1FBR0xDLEtBQUssRUFBRSxNQUhGO1FBSUxDLGVBQWUsRUFBRSxNQUpaO1FBS0xDLE1BQU0sRUFBRSxnQkFMSDtRQU1MQyxZQUFZLEVBQUUsS0FOVDtRQU9MQyxPQUFPLEVBQUUsTUFQSjtRQVFMQyxjQUFjLEVBQUUsUUFSWDtRQVNMQyxVQUFVLEVBQUUsUUFUUDtRQVVMQyxTQUFTLEVBQUU7TUFWTjtJQUZUO0VBcEJKLEVBREY7QUF1Q0QsQ0F4Q0Q7O0tBQU1oQjtBQTBDTiwrREFBZUEsTUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9TbGlkZXIudHN4PzZhYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tIFwicmVhY3QtcmFuZ2VcIjtcbmltcG9ydCB7IFNsaWRlclByb3BzIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmNvbnN0IFNsaWRlcjogUmVhY3QuRkM8U2xpZGVyUHJvcHM+ID0gKHsgbWluLCBtYXgsIHZhbHVlcywgb25DaGFuZ2UgfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxSYW5nZVxuICAgICAgc3RlcD17MX1cbiAgICAgIG1pbj17bWlufVxuICAgICAgbWF4PXttYXh9XG4gICAgICB2YWx1ZXM9e3ZhbHVlc31cbiAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIHJlbmRlclRyYWNrPXsoeyBwcm9wcywgY2hpbGRyZW4gfSkgPT4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAuLi5wcm9wcy5zdHlsZSxcbiAgICAgICAgICAgIGhlaWdodDogXCI2cHhcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjY2NjXCIsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgcmVuZGVyVGh1bWI9eyh7IHByb3BzIH0pID0+IChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjBweFwiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMjBweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2NjY1wiLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICBib3hTaGFkb3c6IFwiMHB4IDJweCA2cHggI2FhYVwiLFxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgIC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJSYW5nZSIsIlNsaWRlciIsIm1pbiIsIm1heCIsInZhbHVlcyIsIm9uQ2hhbmdlIiwicHJvcHMiLCJjaGlsZHJlbiIsInN0eWxlIiwiaGVpZ2h0Iiwid2lkdGgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJkaXNwbGF5IiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiYm94U2hhZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Slider.tsx\n"));

/***/ }),

/***/ "./src/components/SortModal.tsx":
/*!**************************************!*\
  !*** ./src/components/SortModal.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./css/sortModal.module.css */ \"./src/components/css/sortModal.module.css\");\n/* harmony import */ var _css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Slider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Slider */ \"./src/components/Slider.tsx\");\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst SortModal = ({\n  dogData,\n  filterProps: {\n    ageMin,\n    ageMax,\n    isAscending,\n    setAgeMin,\n    setAgeMax,\n    setIsAscending,\n    setCurrentPage,\n    sortBy,\n    setSortBy,\n    cityFilter,\n    setCityFilter,\n    stateFilter,\n    setStateFilter,\n    zipFilter,\n    setZipFilter\n  },\n  onClose\n}) => {\n  _s();\n\n  const [localTempAgeMin, setLocalTempAgeMin] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(ageMin);\n  const [localTempAgeMax, setLocalTempAgeMax] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(ageMax);\n  const [localIsAscending, setLocalIsAscending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isAscending);\n  const [localSortBy, setLocalSortBy] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(sortBy);\n  const [localCityFilter, setLocalCityFilter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(cityFilter);\n  const [localStateFilter, setLocalStateFilter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(stateFilter);\n  const [localZipFilter, setLocalZipFilter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(zipFilter);\n\n  const applyTempFilters = () => {\n    setAgeMin(localTempAgeMin);\n    setAgeMax(localTempAgeMax);\n    setIsAscending(localIsAscending);\n    setSortBy(localSortBy);\n    setCityFilter(localCityFilter);\n    setStateFilter(localStateFilter);\n    setZipFilter(localZipFilter);\n    setCurrentPage(1);\n  };\n\n  const applyChangesAndClose = () => {\n    applyTempFilters();\n    onClose();\n  };\n\n  const getCurrentSortOption = () => {\n    if (localSortBy === \"breed\" && localIsAscending) return \"Breed Name (A - Z)\";\n    if (localSortBy === \"breed\" && !localIsAscending) return \"Breed Name (Z - A)\";\n    if (localSortBy === \"age\" && localIsAscending) return \"Age (Low - High)\";\n    if (localSortBy === \"age\" && !localIsAscending) return \"Age (High - Low)\";\n    return \"Age (Low - High)\";\n  };\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().modalOverlay),\n    onClick: onClose\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().sortModal)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().modal),\n    onClick: e => e.stopPropagation()\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    onClick: onClose,\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().closeButton)\n  }, \"X\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().sortSection)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Sort by\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"select\", {\n    value: getCurrentSortOption(),\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().breedSortSelect),\n    onChange: e => {\n      const value = e.target.value;\n\n      if (value.includes(\"Breed\")) {\n        setLocalSortBy(\"breed\");\n      } else {\n        setLocalSortBy(\"age\");\n      }\n\n      setLocalIsAscending(value.includes(\"A - Z\") || value.includes(\"Low - High\"));\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: \"Age (Low - High)\"\n  }, \"Age (Low - High)\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: \"Age (High - Low)\"\n  }, \"Age (High - Low)\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: \"Breed Name (A - Z)\"\n  }, \"Breed Name (A - Z)\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: \"Breed Name (Z - A)\"\n  }, \"Breed Name (Z - A)\"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().filterSection)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"h3\", null, \"Filters\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().ageFilters)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_Slider__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    min: 0,\n    max: 15,\n    values: [localTempAgeMin ?? 0, localTempAgeMax ?? 15],\n    onChange: values => {\n      setLocalTempAgeMin(values[0]);\n      setLocalTempAgeMax(values[1]);\n    }\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().locationFilter)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"label\", null, \"City:\", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    list: \"cityOptions\",\n    value: localCityFilter ?? \"\",\n    onChange: e => setLocalCityFilter(e.target.value)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"datalist\", {\n    id: \"cityOptions\"\n  }, dogData.map(dog => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: dog.city,\n    key: dog.id + \"_city\"\n  }))))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().locationFilter)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"label\", null, \"State:\", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    list: \"stateOptions\",\n    value: localStateFilter ?? \"\",\n    onChange: e => setLocalStateFilter(e.target.value)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"datalist\", {\n    id: \"stateOptions\"\n  }, dogData.map(dog => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: dog.state,\n    key: dog.id + \"_state\"\n  }))))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().locationFilter)\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"label\", null, \"Zip Code:\", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", {\n    list: \"zipOptions\",\n    value: localZipFilter ?? \"\",\n    onChange: e => setLocalZipFilter(e.target.value)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"datalist\", {\n    id: \"zipOptions\"\n  }, dogData.map(dog => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"option\", {\n    value: dog.zip_code,\n    key: dog.id + \"_zip\"\n  })))))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"button\", {\n    onClick: applyChangesAndClose,\n    className: (_css_sortModal_module_css__WEBPACK_IMPORTED_MODULE_2___default().applyFilterButton)\n  }, \"Apply\"))));\n};\n\n_s(SortModal, \"kQoX6Q6eCuzNYnOsYTy0ZiG1XwI=\");\n\n_c = SortModal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (SortModal);\n\nvar _c;\n\n$RefreshReg$(_c, \"SortModal\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVUsRUFBRSxFQUFDO0VBQWIsR0FDRzNDLE9BQU8sQ0FBQ2tELEdBQVIsQ0FBYUMsR0FBRCxpQkFDWDtJQUFRLEtBQUssRUFBRUEsR0FBRyxDQUFDSSxRQUFuQjtJQUE2QixHQUFHLEVBQUVKLEdBQUcsQ0FBQ0UsRUFBSixHQUFTO0VBQTNDLEVBREQsQ0FESCxDQVBGLENBREYsQ0E3Q0YsQ0E1QkYsZUEwRkU7SUFDRSxPQUFPLEVBQUVwQixvQkFEWDtJQUVFLFNBQVMsRUFBRXBDLG9GQUF3QjJEO0VBRnJDLEdBR0MsT0FIRCxDQTFGRixDQURGLENBREYsQ0FERjtBQXVHRCxDQXJLRDs7R0FBTXpEOztLQUFBQTtBQXVLTiwrREFBZUEsU0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Tb3J0TW9kYWwudHN4P2MyNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuL2Nzcy9zb3J0TW9kYWwubW9kdWxlLmNzc1wiO1xuaW1wb3J0IHsgU29ydE1vZGFsUHJvcHMgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4vU2xpZGVyXCI7XG5cbmNvbnN0IFNvcnRNb2RhbDogUmVhY3QuRkM8U29ydE1vZGFsUHJvcHM+ID0gKHtcbiAgZG9nRGF0YSxcbiAgZmlsdGVyUHJvcHM6IHtcbiAgICBhZ2VNaW4sXG4gICAgYWdlTWF4LFxuICAgIGlzQXNjZW5kaW5nLFxuICAgIHNldEFnZU1pbixcbiAgICBzZXRBZ2VNYXgsXG4gICAgc2V0SXNBc2NlbmRpbmcsXG4gICAgc2V0Q3VycmVudFBhZ2UsXG4gICAgc29ydEJ5LFxuICAgIHNldFNvcnRCeSxcbiAgICBjaXR5RmlsdGVyLFxuICAgIHNldENpdHlGaWx0ZXIsXG4gICAgc3RhdGVGaWx0ZXIsXG4gICAgc2V0U3RhdGVGaWx0ZXIsXG4gICAgemlwRmlsdGVyLFxuICAgIHNldFppcEZpbHRlcixcbiAgfSxcbiAgb25DbG9zZSxcbn0pID0+IHtcbiAgY29uc3QgW2xvY2FsVGVtcEFnZU1pbiwgc2V0TG9jYWxUZW1wQWdlTWluXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KGFnZU1pbik7XG4gIGNvbnN0IFtsb2NhbFRlbXBBZ2VNYXgsIHNldExvY2FsVGVtcEFnZU1heF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihhZ2VNYXgpO1xuICBjb25zdCBbbG9jYWxJc0FzY2VuZGluZywgc2V0TG9jYWxJc0FzY2VuZGluZ10gPVxuICAgIHVzZVN0YXRlPGJvb2xlYW4+KGlzQXNjZW5kaW5nKTtcbiAgY29uc3QgW2xvY2FsU29ydEJ5LCBzZXRMb2NhbFNvcnRCeV0gPSB1c2VTdGF0ZTxcImJyZWVkXCIgfCBcImFnZVwiPihzb3J0QnkpO1xuICBjb25zdCBbbG9jYWxDaXR5RmlsdGVyLCBzZXRMb2NhbENpdHlGaWx0ZXJdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4oXG4gICAgY2l0eUZpbHRlclxuICApO1xuICBjb25zdCBbbG9jYWxTdGF0ZUZpbHRlciwgc2V0TG9jYWxTdGF0ZUZpbHRlcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihcbiAgICBzdGF0ZUZpbHRlclxuICApO1xuICBjb25zdCBbbG9jYWxaaXBGaWx0ZXIsIHNldExvY2FsWmlwRmlsdGVyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KFxuICAgIHppcEZpbHRlclxuICApO1xuXG4gIGNvbnN0IGFwcGx5VGVtcEZpbHRlcnMgPSAoKSA9PiB7XG4gICAgc2V0QWdlTWluKGxvY2FsVGVtcEFnZU1pbik7XG4gICAgc2V0QWdlTWF4KGxvY2FsVGVtcEFnZU1heCk7XG4gICAgc2V0SXNBc2NlbmRpbmcobG9jYWxJc0FzY2VuZGluZyk7XG4gICAgc2V0U29ydEJ5KGxvY2FsU29ydEJ5KTtcbiAgICBzZXRDaXR5RmlsdGVyKGxvY2FsQ2l0eUZpbHRlcik7XG4gICAgc2V0U3RhdGVGaWx0ZXIobG9jYWxTdGF0ZUZpbHRlcik7XG4gICAgc2V0WmlwRmlsdGVyKGxvY2FsWmlwRmlsdGVyKTtcbiAgICBzZXRDdXJyZW50UGFnZSgxKTtcbiAgfTtcblxuICBjb25zdCBhcHBseUNoYW5nZXNBbmRDbG9zZSA9ICgpID0+IHtcbiAgICBhcHBseVRlbXBGaWx0ZXJzKCk7XG4gICAgb25DbG9zZSgpO1xuICB9O1xuXG4gIGNvbnN0IGdldEN1cnJlbnRTb3J0T3B0aW9uID0gKCk6IHN0cmluZyA9PiB7XG4gICAgaWYgKGxvY2FsU29ydEJ5ID09PSBcImJyZWVkXCIgJiYgbG9jYWxJc0FzY2VuZGluZylcbiAgICAgIHJldHVybiBcIkJyZWVkIE5hbWUgKEEgLSBaKVwiO1xuICAgIGlmIChsb2NhbFNvcnRCeSA9PT0gXCJicmVlZFwiICYmICFsb2NhbElzQXNjZW5kaW5nKVxuICAgICAgcmV0dXJuIFwiQnJlZWQgTmFtZSAoWiAtIEEpXCI7XG4gICAgaWYgKGxvY2FsU29ydEJ5ID09PSBcImFnZVwiICYmIGxvY2FsSXNBc2NlbmRpbmcpIHJldHVybiBcIkFnZSAoTG93IC0gSGlnaClcIjtcbiAgICBpZiAobG9jYWxTb3J0QnkgPT09IFwiYWdlXCIgJiYgIWxvY2FsSXNBc2NlbmRpbmcpIHJldHVybiBcIkFnZSAoSGlnaCAtIExvdylcIjtcbiAgICByZXR1cm4gXCJBZ2UgKExvdyAtIEhpZ2gpXCI7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLm1vZGFsT3ZlcmxheX0gb25DbGljaz17b25DbG9zZX0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNvcnRNb2RhbH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubW9kYWx9IG9uQ2xpY2s9eyhlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpfT5cbiAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uQ2xvc2V9IGNsYXNzTmFtZT17c3R5bGVzLmNsb3NlQnV0dG9ufT5cbiAgICAgICAgICAgIFhcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNvcnRTZWN0aW9ufT5cbiAgICAgICAgICAgIDxoMz5Tb3J0IGJ5PC9oMz5cbiAgICAgICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgICAgdmFsdWU9e2dldEN1cnJlbnRTb3J0T3B0aW9uKCl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmJyZWVkU29ydFNlbGVjdH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJCcmVlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgc2V0TG9jYWxTb3J0QnkoXCJicmVlZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2V0TG9jYWxTb3J0QnkoXCJhZ2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldExvY2FsSXNBc2NlbmRpbmcoXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5pbmNsdWRlcyhcIkEgLSBaXCIpIHx8IHZhbHVlLmluY2x1ZGVzKFwiTG93IC0gSGlnaFwiKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJBZ2UgKExvdyAtIEhpZ2gpXCI+QWdlIChMb3cgLSBIaWdoKTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiQWdlIChIaWdoIC0gTG93KVwiPkFnZSAoSGlnaCAtIExvdyk8L29wdGlvbj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIkJyZWVkIE5hbWUgKEEgLSBaKVwiPkJyZWVkIE5hbWUgKEEgLSBaKTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiQnJlZWQgTmFtZSAoWiAtIEEpXCI+QnJlZWQgTmFtZSAoWiAtIEEpPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZmlsdGVyU2VjdGlvbn0+XG4gICAgICAgICAgICA8aDM+RmlsdGVyczwvaDM+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmFnZUZpbHRlcnN9PlxuICAgICAgICAgICAgICA8U2xpZGVyXG4gICAgICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgICAgIG1heD17MTV9XG4gICAgICAgICAgICAgICAgdmFsdWVzPXtbbG9jYWxUZW1wQWdlTWluID8/IDAsIGxvY2FsVGVtcEFnZU1heCA/PyAxNV19XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNldExvY2FsVGVtcEFnZU1pbih2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgc2V0TG9jYWxUZW1wQWdlTWF4KHZhbHVlc1sxXSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5sb2NhdGlvbkZpbHRlcn0+XG4gICAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgICBDaXR5OlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgbGlzdD1cImNpdHlPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbENpdHlGaWx0ZXIgPz8gXCJcIn1cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0TG9jYWxDaXR5RmlsdGVyKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkYXRhbGlzdCBpZD1cImNpdHlPcHRpb25zXCI+XG4gICAgICAgICAgICAgICAgICB7ZG9nRGF0YS5tYXAoKGRvZykgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtkb2cuY2l0eX0ga2V5PXtkb2cuaWQgKyBcIl9jaXR5XCJ9IC8+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L2RhdGFsaXN0PlxuICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubG9jYXRpb25GaWx0ZXJ9PlxuICAgICAgICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICAgICAgU3RhdGU6XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICBsaXN0PVwic3RhdGVPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFN0YXRlRmlsdGVyID8/IFwiXCJ9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldExvY2FsU3RhdGVGaWx0ZXIoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPGRhdGFsaXN0IGlkPVwic3RhdGVPcHRpb25zXCI+XG4gICAgICAgICAgICAgICAgICB7ZG9nRGF0YS5tYXAoKGRvZykgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtkb2cuc3RhdGV9IGtleT17ZG9nLmlkICsgXCJfc3RhdGVcIn0gLz5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvZGF0YWxpc3Q+XG4gICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5sb2NhdGlvbkZpbHRlcn0+XG4gICAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgICBaaXAgQ29kZTpcbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgIGxpc3Q9XCJ6aXBPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgIHZhbHVlPXtsb2NhbFppcEZpbHRlciA/PyBcIlwifVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRMb2NhbFppcEZpbHRlcihlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8ZGF0YWxpc3QgaWQ9XCJ6aXBPcHRpb25zXCI+XG4gICAgICAgICAgICAgICAgICB7ZG9nRGF0YS5tYXAoKGRvZykgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtkb2cuemlwX2NvZGV9IGtleT17ZG9nLmlkICsgXCJfemlwXCJ9IC8+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L2RhdGFsaXN0PlxuICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXthcHBseUNoYW5nZXNBbmRDbG9zZX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmFwcGx5RmlsdGVyQnV0dG9ufVxuICAgICAgICAgID5cbiAgICAgICAgICAgIEFwcGx5XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0TW9kYWw7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInN0eWxlcyIsIlNsaWRlciIsIlNvcnRNb2RhbCIsImRvZ0RhdGEiLCJmaWx0ZXJQcm9wcyIsImFnZU1pbiIsImFnZU1heCIsImlzQXNjZW5kaW5nIiwic2V0QWdlTWluIiwic2V0QWdlTWF4Iiwic2V0SXNBc2NlbmRpbmciLCJzZXRDdXJyZW50UGFnZSIsInNvcnRCeSIsInNldFNvcnRCeSIsImNpdHlGaWx0ZXIiLCJzZXRDaXR5RmlsdGVyIiwic3RhdGVGaWx0ZXIiLCJzZXRTdGF0ZUZpbHRlciIsInppcEZpbHRlciIsInNldFppcEZpbHRlciIsIm9uQ2xvc2UiLCJsb2NhbFRlbXBBZ2VNaW4iLCJzZXRMb2NhbFRlbXBBZ2VNaW4iLCJsb2NhbFRlbXBBZ2VNYXgiLCJzZXRMb2NhbFRlbXBBZ2VNYXgiLCJsb2NhbElzQXNjZW5kaW5nIiwic2V0TG9jYWxJc0FzY2VuZGluZyIsImxvY2FsU29ydEJ5Iiwic2V0TG9jYWxTb3J0QnkiLCJsb2NhbENpdHlGaWx0ZXIiLCJzZXRMb2NhbENpdHlGaWx0ZXIiLCJsb2NhbFN0YXRlRmlsdGVyIiwic2V0TG9jYWxTdGF0ZUZpbHRlciIsImxvY2FsWmlwRmlsdGVyIiwic2V0TG9jYWxaaXBGaWx0ZXIiLCJhcHBseVRlbXBGaWx0ZXJzIiwiYXBwbHlDaGFuZ2VzQW5kQ2xvc2UiLCJnZXRDdXJyZW50U29ydE9wdGlvbiIsIm1vZGFsT3ZlcmxheSIsInNvcnRNb2RhbCIsIm1vZGFsIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsImNsb3NlQnV0dG9uIiwic29ydFNlY3Rpb24iLCJicmVlZFNvcnRTZWxlY3QiLCJ2YWx1ZSIsInRhcmdldCIsImluY2x1ZGVzIiwiZmlsdGVyU2VjdGlvbiIsImFnZUZpbHRlcnMiLCJ2YWx1ZXMiLCJsb2NhdGlvbkZpbHRlciIsIm1hcCIsImRvZyIsImNpdHkiLCJpZCIsInN0YXRlIiwiemlwX2NvZGUiLCJhcHBseUZpbHRlckJ1dHRvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/SortModal.tsx\n"));

/***/ }),

/***/ "./node_modules/react-range/lib/Range.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/Range.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/react-range/lib/utils.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/react-range/lib/types.js\");\nvar INCREASE_KEYS = ['ArrowRight', 'ArrowUp', 'k', 'PageUp'];\nvar DECREASE_KEYS = ['ArrowLeft', 'ArrowDown', 'j', 'PageDown'];\nvar Range = /** @class */ (function (_super) {\n    __extends(Range, _super);\n    function Range(props) {\n        var _this = _super.call(this, props) || this;\n        _this.trackRef = React.createRef();\n        _this.thumbRefs = [];\n        _this.state = {\n            draggedTrackPos: [-1, -1],\n            draggedThumbIndex: -1,\n            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function (t, i) { return i; }),\n            isChanged: false,\n            markOffsets: []\n        };\n        _this.getOffsets = function () {\n            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;\n            var trackElement = _this.trackRef.current;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackPadding = (0, utils_1.getPaddingAndBorder)(trackElement);\n            return _this.getThumbs().map(function (thumb, index) {\n                var thumbOffsets = { x: 0, y: 0 };\n                var thumbRect = thumb.getBoundingClientRect();\n                var thumbMargins = (0, utils_1.getMargin)(thumb);\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Left:\n                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width -\n                                trackRect.width * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Up:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height -\n                                trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Down:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height * (0, utils_1.relativeValue)(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    default:\n                        return (0, utils_1.assertUnreachable)(direction);\n                }\n            });\n        };\n        _this.getThumbs = function () {\n            if (_this.trackRef && _this.trackRef.current) {\n                return Array.from(_this.trackRef.current.children).filter(function (el) {\n                    return el.hasAttribute('aria-valuenow');\n                });\n            }\n            console.warn('No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?');\n            return [];\n        };\n        _this.getTargetIndex = function (e) {\n            return _this.getThumbs().findIndex(function (child) { return child === e.target || child.contains(e.target); });\n        };\n        _this.addTouchEvents = function (e) {\n            document.addEventListener('touchmove', _this.schdOnTouchMove, {\n                passive: false\n            });\n            document.addEventListener('touchend', _this.schdOnEnd, {\n                passive: false\n            });\n            document.addEventListener('touchcancel', _this.schdOnEnd, {\n                passive: false\n            });\n        };\n        _this.addMouseEvents = function (e) {\n            document.addEventListener('mousemove', _this.schdOnMouseMove);\n            document.addEventListener('mouseup', _this.schdOnEnd);\n        };\n        _this.onMouseDownTrack = function (e) {\n            var _a;\n            if (e.button !== 0)\n                return;\n            e.persist();\n            e.preventDefault();\n            _this.addMouseEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.clientX, e.clientY]\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function (t) { return t.current; }), e.clientX, e.clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n        };\n        _this.onResize = function () {\n            (0, utils_1.translateThumbs)(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);\n            _this.calculateMarkOffsets();\n        };\n        _this.onTouchStartTrack = function (e) {\n            var _a;\n            e.persist();\n            _this.addTouchEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.touches[0].clientX, e.touches[0].clientY]\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = (0, utils_1.getClosestThumbIndex)(_this.thumbRefs.map(function (t) { return t.current; }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n        };\n        _this.onMouseOrTouchStart = function (e) {\n            if (_this.props.disabled)\n                return;\n            var isTouch = (0, utils_1.isTouchEvent)(e);\n            if (!isTouch && e.button !== 0)\n                return;\n            var index = _this.getTargetIndex(e);\n            if (index === -1)\n                return;\n            if (isTouch) {\n                _this.addTouchEvents(e);\n            }\n            else {\n                _this.addMouseEvents(e);\n            }\n            _this.setState({\n                draggedThumbIndex: index,\n                thumbZIndexes: _this.state.thumbZIndexes.map(function (t, i) {\n                    if (i === index) {\n                        return Math.max.apply(Math, _this.state.thumbZIndexes);\n                    }\n                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;\n                })\n            });\n        };\n        _this.onMouseMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.clientX, e.clientY);\n        };\n        _this.onTouchMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n        };\n        _this.onKeyDown = function (e) {\n            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl, direction = _a.direction;\n            var isChanged = _this.state.isChanged;\n            var index = _this.getTargetIndex(e.nativeEvent);\n            var inverter = rtl || direction === types_1.Direction.Left || direction === types_1.Direction.Down\n                ? -1\n                : 1;\n            if (index === -1)\n                return;\n            if (INCREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] + inverter * (e.key === 'PageUp' ? step * 10 : step), index)));\n            }\n            else if (DECREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange((0, utils_1.replaceAt)(values, index, _this.normalizeValue(values[index] -\n                    inverter * (e.key === 'PageDown' ? step * 10 : step), index)));\n            }\n            else if (e.key === 'Tab') {\n                _this.setState({ draggedThumbIndex: -1 }, function () {\n                    // If key pressed when thumb was moving, fire onFinalChange\n                    if (isChanged) {\n                        _this.fireOnFinalChange();\n                    }\n                });\n            }\n            else {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            }\n        };\n        _this.onKeyUp = function (e) {\n            var isChanged = _this.state.isChanged;\n            _this.setState({\n                draggedThumbIndex: -1\n            }, function () {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            });\n        };\n        _this.onMove = function (clientX, clientY) {\n            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;\n            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;\n            if (draggedThumbIndex === -1 &&\n                draggedTrackPos[0] === -1 &&\n                draggedTrackPos[1] === -1)\n                return null;\n            var trackElement = _this.trackRef.current;\n            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()\n            if (!trackElement)\n                return null;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackLength = (0, utils_1.isVertical)(direction)\n                ? trackRect.height\n                : trackRect.width;\n            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {\n                // calculate how much it moved since the last update\n                var dX = clientX - draggedTrackPos[0];\n                var dY = clientY - draggedTrackPos[1];\n                // calculate the delta of the value\n                var deltaValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                    case types_1.Direction.Left:\n                        deltaValue = (dX / trackLength) * (max - min);\n                        break;\n                    case types_1.Direction.Down:\n                    case types_1.Direction.Up:\n                        deltaValue = (dY / trackLength) * (max - min);\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    deltaValue *= -1;\n                }\n                if (Math.abs(deltaValue) >= step / 2) {\n                    // adjust delta so it fits into the range\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        if ((values[i] === max && Math.sign(deltaValue) === 1) ||\n                            (values[i] === min && Math.sign(deltaValue) === -1))\n                            return;\n                        var thumbValue = values[i] + deltaValue;\n                        if (thumbValue > max)\n                            deltaValue = max - values[i];\n                        else if (thumbValue < min)\n                            deltaValue = min - values[i];\n                    }\n                    // add the delta to each thumb\n                    var newValues = values.slice(0);\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        newValues = (0, utils_1.replaceAt)(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));\n                    }\n                    _this.setState({\n                        draggedTrackPos: [clientX, clientY]\n                    });\n                    onChange(newValues);\n                }\n            }\n            else {\n                var newValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        newValue =\n                            ((clientX - trackRect.left) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Left:\n                        newValue =\n                            ((trackLength - (clientX - trackRect.left)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    case types_1.Direction.Down:\n                        newValue =\n                            ((clientY - trackRect.top) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Up:\n                        newValue =\n                            ((trackLength - (clientY - trackRect.top)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    default:\n                        (0, utils_1.assertUnreachable)(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    newValue = max + min - newValue;\n                }\n                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {\n                    onChange((0, utils_1.replaceAt)(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));\n                }\n            }\n        };\n        _this.normalizeValue = function (value, index) {\n            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;\n            return (0, utils_1.normalizeValue)(value, index, min, max, step, allowOverlap, values);\n        };\n        _this.onEnd = function (e) {\n            e.preventDefault();\n            document.removeEventListener('mousemove', _this.schdOnMouseMove);\n            document.removeEventListener('touchmove', _this.schdOnTouchMove);\n            document.removeEventListener('mouseup', _this.schdOnEnd);\n            document.removeEventListener('touchend', _this.schdOnEnd);\n            document.removeEventListener('touchcancel', _this.schdOnEnd);\n            if (_this.state.draggedThumbIndex === -1 &&\n                _this.state.draggedTrackPos[0] === -1 &&\n                _this.state.draggedTrackPos[1] === -1)\n                return null;\n            _this.setState({ draggedThumbIndex: -1, draggedTrackPos: [-1, -1] }, function () {\n                _this.fireOnFinalChange();\n            });\n        };\n        _this.fireOnFinalChange = function () {\n            _this.setState({ isChanged: false });\n            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;\n            if (onFinalChange) {\n                onFinalChange(values);\n            }\n        };\n        _this.updateMarkRefs = function (props) {\n            if (!props.renderMark) { // don't create mark refs unless we are rendering marks\n                _this.numOfMarks = undefined;\n                _this.markRefs = undefined;\n                return;\n            }\n            _this.numOfMarks = (props.max - props.min) / _this.props.step;\n            _this.markRefs = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                _this.markRefs[i] = React.createRef();\n            }\n        };\n        _this.calculateMarkOffsets = function () {\n            if (!_this.props.renderMark ||\n                !_this.trackRef ||\n                !_this.numOfMarks ||\n                !_this.markRefs ||\n                _this.trackRef.current === null)\n                return;\n            var elStyles = window.getComputedStyle(_this.trackRef.current);\n            var trackWidth = parseInt(elStyles.width, 10);\n            var trackHeight = parseInt(elStyles.height, 10);\n            var paddingLeft = parseInt(elStyles.paddingLeft, 10);\n            var paddingTop = parseInt(elStyles.paddingTop, 10);\n            var res = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                var markHeight = 9999;\n                var markWidth = 9999;\n                if (_this.markRefs[i].current) {\n                    var markRect = _this.markRefs[i].current.getBoundingClientRect();\n                    markHeight = markRect.height;\n                    markWidth = markRect.width;\n                }\n                if (_this.props.direction === types_1.Direction.Left ||\n                    _this.props.direction === types_1.Direction.Right) {\n                    res.push([\n                        Math.round((trackWidth / _this.numOfMarks) * i + paddingLeft - markWidth / 2),\n                        -Math.round((markHeight - trackHeight) / 2)\n                    ]);\n                }\n                else {\n                    res.push([\n                        Math.round((trackHeight / _this.numOfMarks) * i + paddingTop - markHeight / 2),\n                        -Math.round((markWidth - trackWidth) / 2)\n                    ]);\n                }\n            }\n            _this.setState({ markOffsets: res });\n        };\n        if (props.step === 0) {\n            throw new Error('\"step\" property should be a positive number');\n        }\n        _this.schdOnMouseMove = (0, utils_1.schd)(_this.onMouseMove);\n        _this.schdOnTouchMove = (0, utils_1.schd)(_this.onTouchMove);\n        _this.schdOnEnd = (0, utils_1.schd)(_this.onEnd);\n        _this.thumbRefs = props.values.map(function () { return React.createRef(); });\n        _this.updateMarkRefs(props);\n        return _this;\n    }\n    Range.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;\n        this.resizeObserver = window.ResizeObserver\n            ? new window.ResizeObserver(this.onResize)\n            : {\n                observe: function () { return window.addEventListener('resize', _this.onResize); },\n                unobserve: function () { return window.removeEventListener('resize', _this.onResize); }\n            };\n        document.addEventListener('touchstart', this.onMouseOrTouchStart, {\n            passive: false\n        });\n        document.addEventListener('mousedown', this.onMouseOrTouchStart, {\n            passive: false\n        });\n        !this.props.allowOverlap && (0, utils_1.checkInitialOverlap)(this.props.values);\n        this.props.values.forEach(function (value) {\n            return (0, utils_1.checkBoundaries)(value, _this.props.min, _this.props.max);\n        });\n        this.resizeObserver.observe(this.trackRef.current);\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), this.props.rtl);\n        this.calculateMarkOffsets();\n        values.forEach(function (value) {\n            if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');\n            }\n        });\n    };\n    Range.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step) {\n            this.updateMarkRefs(this.props);\n        }\n        (0, utils_1.translateThumbs)(this.getThumbs(), this.getOffsets(), rtl);\n        // ensure offsets are calculated when the refs for the marks have been created\n        // and those refs have been mounted to the dom\n        // on the state update in calculateOffsets with new markOffsets are calculated\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step ||\n            prevState.markOffsets.length !== this.state.markOffsets.length) {\n            this.calculateMarkOffsets();\n            values.forEach(function (value) {\n                if (!(0, utils_1.isStepDivisible)(min, value, step)) {\n                    console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');\n                }\n            });\n        }\n    };\n    Range.prototype.componentWillUnmount = function () {\n        var options = {\n            passive: false\n        };\n        document.removeEventListener('mousedown', this.onMouseOrTouchStart, options);\n        // These need to be removed!!\n        document.removeEventListener('mousemove', this.schdOnMouseMove);\n        document.removeEventListener('touchmove', this.schdOnTouchMove);\n        document.removeEventListener('touchstart', this.onMouseOrTouchStart);\n        document.removeEventListener('mouseup', this.schdOnEnd);\n        document.removeEventListener('touchend', this.schdOnEnd);\n        this.resizeObserver.unobserve(this.trackRef.current);\n    };\n    Range.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function () { return null; } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;\n        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;\n        return renderTrack({\n            props: {\n                style: {\n                    // creates stacking context that prevents z-index applied to thumbs\n                    // interfere with other elements\n                    transform: 'scale(1)',\n                    cursor: draggedThumbIndex > -1\n                        ? 'grabbing'\n                        : this.props.draggableTrack\n                            ? (0, utils_1.isVertical)(this.props.direction)\n                                ? 'ns-resize'\n                                : 'ew-resize'\n                            : values.length === 1 && !disabled\n                                ? 'pointer'\n                                : 'inherit'\n                },\n                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,\n                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,\n                ref: this.trackRef\n            },\n            isDragged: this.state.draggedThumbIndex > -1,\n            disabled: disabled,\n            children: __spreadArray(__spreadArray([], markOffsets.map(function (offset, index, arr) {\n                return renderMark({\n                    props: {\n                        style: _this.props.direction === types_1.Direction.Left ||\n                            _this.props.direction === types_1.Direction.Right\n                            ? {\n                                position: 'absolute',\n                                left: \"\".concat(offset[0], \"px\"),\n                                marginTop: \"\".concat(offset[1], \"px\")\n                            }\n                            : {\n                                position: 'absolute',\n                                top: \"\".concat(offset[0], \"px\"),\n                                marginLeft: \"\".concat(offset[1], \"px\")\n                            },\n                        key: \"mark\".concat(index),\n                        ref: _this.markRefs[index]\n                    },\n                    index: index\n                });\n            }), true), values.map(function (value, index) {\n                var isDragged = _this.state.draggedThumbIndex === index;\n                return renderThumb({\n                    index: index,\n                    value: value,\n                    isDragged: isDragged,\n                    props: {\n                        style: {\n                            position: 'absolute',\n                            zIndex: thumbZIndexes[index],\n                            cursor: disabled ? 'inherit' : isDragged ? 'grabbing' : 'grab',\n                            userSelect: 'none',\n                            touchAction: 'none',\n                            WebkitUserSelect: 'none',\n                            MozUserSelect: 'none',\n                            msUserSelect: 'none'\n                        },\n                        key: index,\n                        tabIndex: disabled ? undefined : 0,\n                        'aria-valuemax': allowOverlap ? max : values[index + 1] || max,\n                        'aria-valuemin': allowOverlap ? min : values[index - 1] || min,\n                        'aria-valuenow': value,\n                        draggable: false,\n                        ref: _this.thumbRefs[index],\n                        role: 'slider',\n                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,\n                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp\n                    }\n                });\n            }), true)\n        });\n    };\n    Range.defaultProps = {\n        step: 1,\n        direction: types_1.Direction.Right,\n        rtl: false,\n        disabled: false,\n        allowOverlap: false,\n        draggableTrack: false,\n        min: 0,\n        max: 100\n    };\n    return Range;\n}(React.Component));\nexports[\"default\"] = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL1JhbmdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLG1CQUFPLENBQUMsNENBQU87QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFdBQVc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL1JhbmdlLmpzPzIxNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIElOQ1JFQVNFX0tFWVMgPSBbJ0Fycm93UmlnaHQnLCAnQXJyb3dVcCcsICdrJywgJ1BhZ2VVcCddO1xudmFyIERFQ1JFQVNFX0tFWVMgPSBbJ0Fycm93TGVmdCcsICdBcnJvd0Rvd24nLCAnaicsICdQYWdlRG93biddO1xudmFyIFJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYW5nZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYW5nZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHJhY2tSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMudGh1bWJSZWZzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zOiBbLTEsIC0xXSxcbiAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiAtMSxcbiAgICAgICAgICAgIHRodW1iWkluZGV4ZXM6IG5ldyBBcnJheShfdGhpcy5wcm9wcy52YWx1ZXMubGVuZ3RoKS5maWxsKDApLm1hcChmdW5jdGlvbiAodCwgaSkgeyByZXR1cm4gaTsgfSksXG4gICAgICAgICAgICBpc0NoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWFya09mZnNldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldE9mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgICAgICAgICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzLnRyYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgdHJhY2tSZWN0ID0gdHJhY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRyYWNrUGFkZGluZyA9ICgwLCB1dGlsc18xLmdldFBhZGRpbmdBbmRCb3JkZXIpKHRyYWNrRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0VGh1bWJzKCkubWFwKGZ1bmN0aW9uICh0aHVtYiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJPZmZzZXRzID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICAgICAgdmFyIHRodW1iUmVjdCA9IHRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYk1hcmdpbnMgPSAoMCwgdXRpbHNfMS5nZXRNYXJnaW4pKHRodW1iKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPSAodGh1bWJNYXJnaW5zLmxlZnQgKyB0cmFja1BhZGRpbmcubGVmdCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHRodW1iUmVjdC5oZWlnaHQgLSB0cmFja1JlY3QuaGVpZ2h0KSAvIDIgKyB0cmFja1BhZGRpbmcudG9wKSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3Qud2lkdGggKiAoMCwgdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKSh2YWx1ZXNbaW5kZXhdLCBtaW4sIG1heCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPSAodGh1bWJNYXJnaW5zLnJpZ2h0ICsgdHJhY2tQYWRkaW5nLnJpZ2h0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LmhlaWdodCAtIHRyYWNrUmVjdC5oZWlnaHQpIC8gMiArIHRyYWNrUGFkZGluZy50b3ApICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC53aWR0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC53aWR0aCAqICgwLCB1dGlsc18xLnJlbGF0aXZlVmFsdWUpKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LndpZHRoIC0gdHJhY2tSZWN0LndpZHRoKSAvIDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk1hcmdpbnMubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUGFkZGluZy5sZWZ0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPSAtdHJhY2tQYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3QuaGVpZ2h0ICogKDAsIHV0aWxzXzEucmVsYXRpdmVWYWx1ZSkodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3Qud2lkdGggLSB0cmFja1JlY3Qud2lkdGgpIC8gMiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iTWFyZ2lucy5sZWZ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tQYWRkaW5nLmxlZnQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9IC10cmFja1BhZGRpbmcubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy55ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LmhlaWdodCAqICgwLCB1dGlsc18xLnJlbGF0aXZlVmFsdWUpKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5hc3NlcnRVbnJlYWNoYWJsZSkoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VGh1bWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrUmVmICYmIF90aGlzLnRyYWNrUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShfdGhpcy50cmFja1JlZi5jdXJyZW50LmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gdGh1bWJzIGZvdW5kIGluIHRoZSB0cmFjayBjb250YWluZXIuIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgJiBzcHJlYWQgdGhlIGBwcm9wc2AgcGFyYW0gaW4gcmVuZGVyVHJhY2s/Jyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRhcmdldEluZGV4ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUaHVtYnMoKS5maW5kSW5kZXgoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZCA9PT0gZS50YXJnZXQgfHwgY2hpbGQuY29udGFpbnMoZS50YXJnZXQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMuc2NoZE9uVG91Y2hNb3ZlLCB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfdGhpcy5zY2hkT25FbmQsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLnNjaGRPbkVuZCwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuc2NoZE9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlRG93blRyYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLmFkZE1vdXNlRXZlbnRzKGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGggPiAxICYmIF90aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRodW1iUmVmcy5zb21lKGZ1bmN0aW9uICh0aHVtYlJlZikgeyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aHVtYlJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZS50YXJnZXQpOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBkcmFnZ2luZyB0aGUgd2hvbGUgdHJhY2tcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2UuY2xpZW50WCwgZS5jbGllbnRZXVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgdGh1bWIgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIHZhciBkcmFnZ2VkVGh1bWJJbmRleCA9ICgwLCB1dGlsc18xLmdldENsb3Nlc3RUaHVtYkluZGV4KShfdGhpcy50aHVtYlJlZnMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmN1cnJlbnQ7IH0pLCBlLmNsaWVudFgsIGUuY2xpZW50WSwgX3RoaXMucHJvcHMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSB0aHVtYiB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLnRodW1iUmVmc1tkcmFnZ2VkVGh1bWJJbmRleF0uY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogZHJhZ2dlZFRodW1iSW5kZXhcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMpKF90aGlzLmdldFRodW1icygpLCBfdGhpcy5nZXRPZmZzZXRzKCksIF90aGlzLnByb3BzLnJ0bCk7XG4gICAgICAgICAgICBfdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblRvdWNoU3RhcnRUcmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgICAgIF90aGlzLmFkZFRvdWNoRXZlbnRzKGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGggPiAxICYmIF90aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRodW1iUmVmcy5zb21lKGZ1bmN0aW9uICh0aHVtYlJlZikgeyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aHVtYlJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZS50YXJnZXQpOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBkcmFnZ2luZyB0aGUgd2hvbGUgdHJhY2tcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSB0aHVtYiB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHBsYWNlIHdoZXJlIHRoZSB0cmFjayBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdnZWRUaHVtYkluZGV4ID0gKDAsIHV0aWxzXzEuZ2V0Q2xvc2VzdFRodW1iSW5kZXgpKF90aGlzLnRodW1iUmVmcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuY3VycmVudDsgfSksIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSwgX3RoaXMucHJvcHMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSB0aHVtYiB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLnRodW1iUmVmc1tkcmFnZ2VkVGh1bWJJbmRleF0uY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogZHJhZ2dlZFRodW1iSW5kZXhcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW91c2VPclRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc1RvdWNoID0gKDAsIHV0aWxzXzEuaXNUb3VjaEV2ZW50KShlKTtcbiAgICAgICAgICAgIGlmICghaXNUb3VjaCAmJiBlLmJ1dHRvbiAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5nZXRUYXJnZXRJbmRleChlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRUb3VjaEV2ZW50cyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmFkZE1vdXNlRXZlbnRzKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB0aHVtYlpJbmRleGVzOiBfdGhpcy5zdGF0ZS50aHVtYlpJbmRleGVzLm1hcChmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBfdGhpcy5zdGF0ZS50aHVtYlpJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCA8PSBfdGhpcy5zdGF0ZS50aHVtYlpJbmRleGVzW2luZGV4XSA/IHQgOiB0IC0gMTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLm9uTW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLm9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbktleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHZhbHVlcyA9IF9hLnZhbHVlcywgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgc3RlcCA9IF9hLnN0ZXAsIHJ0bCA9IF9hLnJ0bCwgZGlyZWN0aW9uID0gX2EuZGlyZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IF90aGlzLnN0YXRlLmlzQ2hhbmdlZDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLmdldFRhcmdldEluZGV4KGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgdmFyIGludmVydGVyID0gcnRsIHx8IGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkRvd25cbiAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoSU5DUkVBU0VfS0VZUy5pbmNsdWRlcyhlLmtleSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCgwLCB1dGlsc18xLnJlcGxhY2VBdCkodmFsdWVzLCBpbmRleCwgX3RoaXMubm9ybWFsaXplVmFsdWUodmFsdWVzW2luZGV4XSArIGludmVydGVyICogKGUua2V5ID09PSAnUGFnZVVwJyA/IHN0ZXAgKiAxMCA6IHN0ZXApLCBpbmRleCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKERFQ1JFQVNFX0tFWVMuaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSgoMCwgdXRpbHNfMS5yZXBsYWNlQXQpKHZhbHVlcywgaW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpbmRleF0gLVxuICAgICAgICAgICAgICAgICAgICBpbnZlcnRlciAqIChlLmtleSA9PT0gJ1BhZ2VEb3duJyA/IHN0ZXAgKiAxMCA6IHN0ZXApLCBpbmRleCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZ2dlZFRodW1iSW5kZXg6IC0xIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYga2V5IHByZXNzZWQgd2hlbiB0aHVtYiB3YXMgbW92aW5nLCBmaXJlIG9uRmluYWxDaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25LZXlVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgaXNDaGFuZ2VkID0gX3RoaXMuc3RhdGUuaXNDaGFuZ2VkO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiAtMVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3ZlID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlLCBkcmFnZ2VkVGh1bWJJbmRleCA9IF9hLmRyYWdnZWRUaHVtYkluZGV4LCBkcmFnZ2VkVHJhY2tQb3MgPSBfYS5kcmFnZ2VkVHJhY2tQb3M7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGlyZWN0aW9uID0gX2IuZGlyZWN0aW9uLCBtaW4gPSBfYi5taW4sIG1heCA9IF9iLm1heCwgb25DaGFuZ2UgPSBfYi5vbkNoYW5nZSwgdmFsdWVzID0gX2IudmFsdWVzLCBzdGVwID0gX2Iuc3RlcCwgcnRsID0gX2IucnRsO1xuICAgICAgICAgICAgaWYgKGRyYWdnZWRUaHVtYkluZGV4ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1Bvc1swXSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3NbMV0gPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzLnRyYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBJZiBjb21wb25lbnQgd2FzIGNsb3NlZCBkb3duIHByZW1hdHVyZWx5LCBBIGxhc3Qgb25Nb3ZlIGNvdWxkIGJlIHRyaWdnZXJlZCBiYXNlZCBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKVxuICAgICAgICAgICAgaWYgKCF0cmFja0VsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdHJhY2tSZWN0ID0gdHJhY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gKDAsIHV0aWxzXzEuaXNWZXJ0aWNhbCkoZGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgID8gdHJhY2tSZWN0LmhlaWdodFxuICAgICAgICAgICAgICAgIDogdHJhY2tSZWN0LndpZHRoO1xuICAgICAgICAgICAgaWYgKGRyYWdnZWRUcmFja1Bvc1swXSAhPT0gLTEgJiYgZHJhZ2dlZFRyYWNrUG9zWzFdICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCBpdCBtb3ZlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGVcbiAgICAgICAgICAgICAgICB2YXIgZFggPSBjbGllbnRYIC0gZHJhZ2dlZFRyYWNrUG9zWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkWSA9IGNsaWVudFkgLSBkcmFnZ2VkVHJhY2tQb3NbMV07XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBvZiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGFWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IChkWCAvIHRyYWNrTGVuZ3RoKSAqIChtYXggLSBtaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uRG93bjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSAoZFkgLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUpKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludmVydCBmb3IgUlRMXG4gICAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlICo9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGFWYWx1ZSkgPj0gc3RlcCAvIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IGRlbHRhIHNvIGl0IGZpdHMgaW50byB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy50aHVtYlJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWVzW2ldID09PSBtYXggJiYgTWF0aC5zaWduKGRlbHRhVmFsdWUpID09PSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZXNbaV0gPT09IG1pbiAmJiBNYXRoLnNpZ24oZGVsdGFWYWx1ZSkgPT09IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGh1bWJWYWx1ZSA9IHZhbHVlc1tpXSArIGRlbHRhVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGh1bWJWYWx1ZSA+IG1heClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gbWF4IC0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGh1bWJWYWx1ZSA8IG1pbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gbWluIC0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgZGVsdGEgdG8gZWFjaCB0aHVtYlxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVzID0gdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRodW1iUmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVzID0gKDAsIHV0aWxzXzEucmVwbGFjZUF0KShuZXdWYWx1ZXMsIGksIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpXSArIGRlbHRhVmFsdWUsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFtjbGllbnRYLCBjbGllbnRZXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjbGllbnRYIC0gdHJhY2tSZWN0LmxlZnQpIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodHJhY2tMZW5ndGggLSAoY2xpZW50WCAtIHRyYWNrUmVjdC5sZWZ0KSkgLyB0cmFja0xlbmd0aCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4IC0gbWluKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjbGllbnRZIC0gdHJhY2tSZWN0LnRvcCkgLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodHJhY2tMZW5ndGggLSAoY2xpZW50WSAtIHRyYWNrUmVjdC50b3ApKSAvIHRyYWNrTGVuZ3RoKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXggLSBtaW4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnRVbnJlYWNoYWJsZSkoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0IGZvciBSVExcbiAgICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbWF4ICsgbWluIC0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZXNbZHJhZ2dlZFRodW1iSW5kZXhdIC0gbmV3VmFsdWUpID49IHN0ZXAgLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCgwLCB1dGlsc18xLnJlcGxhY2VBdCkodmFsdWVzLCBkcmFnZ2VkVGh1bWJJbmRleCwgX3RoaXMubm9ybWFsaXplVmFsdWUobmV3VmFsdWUsIGRyYWdnZWRUaHVtYkluZGV4KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubm9ybWFsaXplVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIHN0ZXAgPSBfYS5zdGVwLCBhbGxvd092ZXJsYXAgPSBfYS5hbGxvd092ZXJsYXAsIHZhbHVlcyA9IF9hLnZhbHVlcztcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ub3JtYWxpemVWYWx1ZSkodmFsdWUsIGluZGV4LCBtaW4sIG1heCwgc3RlcCwgYWxsb3dPdmVybGFwLCB2YWx1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMuc2NoZE9uVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmRyYWdnZWRUaHVtYkluZGV4ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmRyYWdnZWRUcmFja1Bvc1swXSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5kcmFnZ2VkVHJhY2tQb3NbMV0gPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBkcmFnZ2VkVGh1bWJJbmRleDogLTEsIGRyYWdnZWRUcmFja1BvczogWy0xLCAtMV0gfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzQ2hhbmdlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgb25GaW5hbENoYW5nZSA9IF9hLm9uRmluYWxDaGFuZ2UsIHZhbHVlcyA9IF9hLnZhbHVlcztcbiAgICAgICAgICAgIGlmIChvbkZpbmFsQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgb25GaW5hbENoYW5nZSh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy51cGRhdGVNYXJrUmVmcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5yZW5kZXJNYXJrKSB7IC8vIGRvbid0IGNyZWF0ZSBtYXJrIHJlZnMgdW5sZXNzIHdlIGFyZSByZW5kZXJpbmcgbWFya3NcbiAgICAgICAgICAgICAgICBfdGhpcy5udW1PZk1hcmtzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLm1hcmtSZWZzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm51bU9mTWFya3MgPSAocHJvcHMubWF4IC0gcHJvcHMubWluKSAvIF90aGlzLnByb3BzLnN0ZXA7XG4gICAgICAgICAgICBfdGhpcy5tYXJrUmVmcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5udW1PZk1hcmtzICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFya1JlZnNbaV0gPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2FsY3VsYXRlTWFya09mZnNldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLnJlbmRlck1hcmsgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMudHJhY2tSZWYgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMubnVtT2ZNYXJrcyB8fFxuICAgICAgICAgICAgICAgICFfdGhpcy5tYXJrUmVmcyB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrUmVmLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGVsU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoX3RoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tXaWR0aCA9IHBhcnNlSW50KGVsU3R5bGVzLndpZHRoLCAxMCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tIZWlnaHQgPSBwYXJzZUludChlbFN0eWxlcy5oZWlnaHQsIDEwKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlSW50KGVsU3R5bGVzLnBhZGRpbmdMZWZ0LCAxMCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlSW50KGVsU3R5bGVzLnBhZGRpbmdUb3AsIDEwKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtT2ZNYXJrcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrSGVpZ2h0ID0gOTk5OTtcbiAgICAgICAgICAgICAgICB2YXIgbWFya1dpZHRoID0gOTk5OTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubWFya1JlZnNbaV0uY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFya1JlY3QgPSBfdGhpcy5tYXJrUmVmc1tpXS5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrSGVpZ2h0ID0gbWFya1JlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBtYXJrV2lkdGggPSBtYXJrUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHRyYWNrV2lkdGggLyBfdGhpcy5udW1PZk1hcmtzKSAqIGkgKyBwYWRkaW5nTGVmdCAtIG1hcmtXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLU1hdGgucm91bmQoKG1hcmtIZWlnaHQgLSB0cmFja0hlaWdodCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHRyYWNrSGVpZ2h0IC8gX3RoaXMubnVtT2ZNYXJrcykgKiBpICsgcGFkZGluZ1RvcCAtIG1hcmtIZWlnaHQgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC1NYXRoLnJvdW5kKChtYXJrV2lkdGggLSB0cmFja1dpZHRoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgbWFya09mZnNldHM6IHJlcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BzLnN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzdGVwXCIgcHJvcGVydHkgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2NoZE9uTW91c2VNb3ZlID0gKDAsIHV0aWxzXzEuc2NoZCkoX3RoaXMub25Nb3VzZU1vdmUpO1xuICAgICAgICBfdGhpcy5zY2hkT25Ub3VjaE1vdmUgPSAoMCwgdXRpbHNfMS5zY2hkKShfdGhpcy5vblRvdWNoTW92ZSk7XG4gICAgICAgIF90aGlzLnNjaGRPbkVuZCA9ICgwLCB1dGlsc18xLnNjaGQpKF90aGlzLm9uRW5kKTtcbiAgICAgICAgX3RoaXMudGh1bWJSZWZzID0gcHJvcHMudmFsdWVzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFjdC5jcmVhdGVSZWYoKTsgfSk7XG4gICAgICAgIF90aGlzLnVwZGF0ZU1hcmtSZWZzKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSYW5nZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBzdGVwID0gX2Euc3RlcDtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHdpbmRvdy5SZXNpemVPYnNlcnZlclxuICAgICAgICAgICAgPyBuZXcgd2luZG93LlJlc2l6ZU9ic2VydmVyKHRoaXMub25SZXNpemUpXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX3RoaXMub25SZXNpemUpOyB9LFxuICAgICAgICAgICAgICAgIHVub2JzZXJ2ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIF90aGlzLm9uUmVzaXplKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgICF0aGlzLnByb3BzLmFsbG93T3ZlcmxhcCAmJiAoMCwgdXRpbHNfMS5jaGVja0luaXRpYWxPdmVybGFwKSh0aGlzLnByb3BzLnZhbHVlcyk7XG4gICAgICAgIHRoaXMucHJvcHMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY2hlY2tCb3VuZGFyaWVzKSh2YWx1ZSwgX3RoaXMucHJvcHMubWluLCBfdGhpcy5wcm9wcy5tYXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgICAgICgwLCB1dGlsc18xLnRyYW5zbGF0ZVRodW1icykodGhpcy5nZXRUaHVtYnMoKSwgdGhpcy5nZXRPZmZzZXRzKCksIHRoaXMucHJvcHMucnRsKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cygpO1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNTdGVwRGl2aXNpYmxlKShtaW4sIHZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGB2YWx1ZXNgIHByb3BlcnR5IGlzIGluIGNvbmZsaWN0IHdpdGggdGhlIGN1cnJlbnQgYHN0ZXBgLCBgbWluYCwgYW5kIGBtYXhgIHByb3BlcnRpZXMuIFBsZWFzZSBwcm92aWRlIHZhbHVlcyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHVzaW5nIHRoZSBtaW4sIG1heCwgYW5kIHN0ZXAgdmFsdWVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbWF4ID0gX2EubWF4LCBtaW4gPSBfYS5taW4sIHN0ZXAgPSBfYS5zdGVwLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHJ0bCA9IF9hLnJ0bDtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tYXggIT09IG1heCB8fFxuICAgICAgICAgICAgcHJldlByb3BzLm1pbiAhPT0gbWluIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMuc3RlcCAhPT0gc3RlcCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrUmVmcyh0aGlzLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMpKHRoaXMuZ2V0VGh1bWJzKCksIHRoaXMuZ2V0T2Zmc2V0cygpLCBydGwpO1xuICAgICAgICAvLyBlbnN1cmUgb2Zmc2V0cyBhcmUgY2FsY3VsYXRlZCB3aGVuIHRoZSByZWZzIGZvciB0aGUgbWFya3MgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgLy8gYW5kIHRob3NlIHJlZnMgaGF2ZSBiZWVuIG1vdW50ZWQgdG8gdGhlIGRvbVxuICAgICAgICAvLyBvbiB0aGUgc3RhdGUgdXBkYXRlIGluIGNhbGN1bGF0ZU9mZnNldHMgd2l0aCBuZXcgbWFya09mZnNldHMgYXJlIGNhbGN1bGF0ZWRcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tYXggIT09IG1heCB8fFxuICAgICAgICAgICAgcHJldlByb3BzLm1pbiAhPT0gbWluIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMuc3RlcCAhPT0gc3RlcCB8fFxuICAgICAgICAgICAgcHJldlN0YXRlLm1hcmtPZmZzZXRzLmxlbmd0aCAhPT0gdGhpcy5zdGF0ZS5tYXJrT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlTWFya09mZnNldHMoKTtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNTdGVwRGl2aXNpYmxlKShtaW4sIHZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBgdmFsdWVzYCBwcm9wZXJ0eSBpcyBpbiBjb25mbGljdCB3aXRoIHRoZSBjdXJyZW50IGBzdGVwYCwgYG1pbmAsIGFuZCBgbWF4YCBwcm9wZXJ0aWVzLiBQbGVhc2UgcHJvdmlkZSB2YWx1ZXMgdGhhdCBhcmUgYWNjZXNzaWJsZSB1c2luZyB0aGUgbWluLCBtYXgsIGFuZCBzdGVwIHZhbHVlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgcmVtb3ZlZCEhXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuc2NoZE9uTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5zY2hkT25Ub3VjaE1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0KTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCByZW5kZXJUcmFjayA9IF9hLnJlbmRlclRyYWNrLCByZW5kZXJUaHVtYiA9IF9hLnJlbmRlclRodW1iLCBfYiA9IF9hLnJlbmRlck1hcmssIHJlbmRlck1hcmsgPSBfYiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSA6IF9iLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBhbGxvd092ZXJsYXAgPSBfYS5hbGxvd092ZXJsYXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQ7XG4gICAgICAgIHZhciBfYyA9IHRoaXMuc3RhdGUsIGRyYWdnZWRUaHVtYkluZGV4ID0gX2MuZHJhZ2dlZFRodW1iSW5kZXgsIHRodW1iWkluZGV4ZXMgPSBfYy50aHVtYlpJbmRleGVzLCBtYXJrT2Zmc2V0cyA9IF9jLm1hcmtPZmZzZXRzO1xuICAgICAgICByZXR1cm4gcmVuZGVyVHJhY2soe1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIHN0YWNraW5nIGNvbnRleHQgdGhhdCBwcmV2ZW50cyB6LWluZGV4IGFwcGxpZWQgdG8gdGh1bWJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVyZmVyZSB3aXRoIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBkcmFnZ2VkVGh1bWJJbmRleCA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdncmFiYmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5kcmFnZ2FibGVUcmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEuaXNWZXJ0aWNhbCkodGhpcy5wcm9wcy5kaXJlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ25zLXJlc2l6ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZXctcmVzaXplJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVzLmxlbmd0aCA9PT0gMSAmJiAhZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAncG9pbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnaW5oZXJpdCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uTW91c2VEb3duOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogdGhpcy5vbk1vdXNlRG93blRyYWNrLFxuICAgICAgICAgICAgICAgIG9uVG91Y2hTdGFydDogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IHRoaXMub25Ub3VjaFN0YXJ0VHJhY2ssXG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLnRyYWNrUmVmXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNEcmFnZ2VkOiB0aGlzLnN0YXRlLmRyYWdnZWRUaHVtYkluZGV4ID4gLTEsXG4gICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBtYXJrT2Zmc2V0cy5tYXAoZnVuY3Rpb24gKG9mZnNldCwgaW5kZXgsIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJNYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChvZmZzZXRbMF0sIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCJcIi5jb25jYXQob2Zmc2V0WzFdLCBcInB4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdChvZmZzZXRbMF0sIFwicHhcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IFwiXCIuY29uY2F0KG9mZnNldFsxXSwgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwibWFya1wiLmNvbmNhdChpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF90aGlzLm1hcmtSZWZzW2luZGV4XVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCB0cnVlKSwgdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRHJhZ2dlZCA9IF90aGlzLnN0YXRlLmRyYWdnZWRUaHVtYkluZGV4ID09PSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyVGh1bWIoe1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnZ2VkOiBpc0RyYWdnZWQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogdGh1bWJaSW5kZXhlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBkaXNhYmxlZCA/ICdpbmhlcml0JyA6IGlzRHJhZ2dlZCA/ICdncmFiYmluZycgOiAnZ3JhYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV2Via2l0VXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1velVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc1VzZXJTZWxlY3Q6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleDogZGlzYWJsZWQgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiBhbGxvd092ZXJsYXAgPyBtYXggOiB2YWx1ZXNbaW5kZXggKyAxXSB8fCBtYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6IGFsbG93T3ZlcmxhcCA/IG1pbiA6IHZhbHVlc1tpbmRleCAtIDFdIHx8IG1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbm93JzogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfdGhpcy50aHVtYlJlZnNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3NsaWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleURvd246IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiBfdGhpcy5vbktleURvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbktleVVwOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogX3RoaXMub25LZXlVcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgdHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSYW5nZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHN0ZXA6IDEsXG4gICAgICAgIGRpcmVjdGlvbjogdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQsXG4gICAgICAgIHJ0bDogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgYWxsb3dPdmVybGFwOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dhYmxlVHJhY2s6IGZhbHNlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAwXG4gICAgfTtcbiAgICByZXR1cm4gUmFuZ2U7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmFuZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-range/lib/Range.js\n"));

/***/ }),

/***/ "./node_modules/react-range/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;\nvar Range_1 = __importDefault(__webpack_require__(/*! ./Range */ \"./node_modules/react-range/lib/Range.js\"));\nexports.Range = Range_1.default;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/react-range/lib/utils.js\");\nObject.defineProperty(exports, \"getTrackBackground\", ({ enumerable: true, get: function () { return utils_1.getTrackBackground; } }));\nObject.defineProperty(exports, \"useThumbOverlap\", ({ enumerable: true, get: function () { return utils_1.useThumbOverlap; } }));\nObject.defineProperty(exports, \"relativeValue\", ({ enumerable: true, get: function () { return utils_1.relativeValue; } }));\nObject.defineProperty(exports, \"checkValuesAgainstBoundaries\", ({ enumerable: true, get: function () { return utils_1.checkValuesAgainstBoundaries; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/react-range/lib/types.js\");\nObject.defineProperty(exports, \"Direction\", ({ enumerable: true, get: function () { return types_1.Direction; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0NBQW9DLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsMEJBQTBCLEdBQUcsYUFBYTtBQUN2Siw4QkFBOEIsbUJBQU8sQ0FBQyx3REFBUztBQUMvQyxhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLHNEQUFxRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNuSSxtREFBa0QsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDN0gsaURBQWdELEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3pILGdFQUErRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUN2SixjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvaW5kZXguanM/YzE5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGV4cG9ydHMucmVsYXRpdmVWYWx1ZSA9IGV4cG9ydHMudXNlVGh1bWJPdmVybGFwID0gZXhwb3J0cy5EaXJlY3Rpb24gPSBleHBvcnRzLmdldFRyYWNrQmFja2dyb3VuZCA9IGV4cG9ydHMuUmFuZ2UgPSB2b2lkIDA7XG52YXIgUmFuZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9SYW5nZVwiKSk7XG5leHBvcnRzLlJhbmdlID0gUmFuZ2VfMS5kZWZhdWx0O1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFRyYWNrQmFja2dyb3VuZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5nZXRUcmFja0JhY2tncm91bmQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VUaHVtYk92ZXJsYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEudXNlVGh1bWJPdmVybGFwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVsYXRpdmVWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5yZWxhdGl2ZVZhbHVlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzOyB9IH0pO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpcmVjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5EaXJlY3Rpb247IH0gfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-range/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/react-range/lib/types.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Direction = void 0;\nvar Direction;\n(function (Direction) {\n    Direction[\"Right\"] = \"to right\";\n    Direction[\"Left\"] = \"to left\";\n    Direction[\"Down\"] = \"to bottom\";\n    Direction[\"Up\"] = \"to top\";\n})(Direction = exports.Direction || (exports.Direction = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQyxpQkFBaUIsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3R5cGVzLmpzP2I0MTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpcmVjdGlvbiA9IHZvaWQgMDtcbnZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltcIlJpZ2h0XCJdID0gXCJ0byByaWdodFwiO1xuICAgIERpcmVjdGlvbltcIkxlZnRcIl0gPSBcInRvIGxlZnRcIjtcbiAgICBEaXJlY3Rpb25bXCJEb3duXCJdID0gXCJ0byBib3R0b21cIjtcbiAgICBEaXJlY3Rpb25bXCJVcFwiXSA9IFwidG8gdG9wXCI7XG59KShEaXJlY3Rpb24gPSBleHBvcnRzLkRpcmVjdGlvbiB8fCAoZXhwb3J0cy5EaXJlY3Rpb24gPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-range/lib/types.js\n"));

/***/ }),

/***/ "./node_modules/react-range/lib/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/react-range/lib/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/react-range/lib/types.js\");\nvar getStepDecimals = function (step) {\n    var decimals = step.toString().split('.')[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) %\n        Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2\n        ? rounded\n        : rounded + step;\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\".concat(min, \") is equal/bigger than max (\").concat(max, \")\"));\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\".concat(value, \") is smaller than min (\").concat(min, \")\"));\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\".concat(value, \") is bigger than max (\").concat(max, \")\"));\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    }\n    else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\".concat(values, \"]} needs to be sorted when allowOverlap={false}\"));\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['margin-top'], 10),\n        bottom: parseInt(style['margin-bottom'], 10),\n        left: parseInt(style['margin-left'], 10),\n        right: parseInt(style['margin-right'], 10)\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),\n        bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),\n        left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),\n        right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for (var i = 1; i < thumbs.length; i++) {\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\".concat(x, \"px, \").concat(y, \"px)\");\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values.slice(0).sort(function (a, b) { return a - b; }).map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return \"\".concat(acc, \", \").concat(colors[index], \" \").concat(point, \"%, \").concat(colors[index + 1], \" \").concat(point, \"%\");\n    }, '');\n    return \"linear-gradient(\".concat(direction, \", \").concat(colors[0], \" 0%\").concat(middle, \", \").concat(colors[colors.length - 1], \" 100%)\");\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArray([thumbEl], Array.from(thumbEl.children), true).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = 'hidden';\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArray(__spreadArray([], overlaps, true), [thumbIndex, siblingIndex], false);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = ' - '; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = (0, exports.getStepDecimals)(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = (0, react_1.useState)({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = (0, react_1.useState)(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    (0, react_1.useEffect)(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArray(__spreadArray([], a, true), [offsets_1[s[i]].x], false) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n                    newStyle.left = \"\".concat(Math.abs(first - (last + lastWidth)) / 2, \"px\");\n                    newStyle.transform = 'translate(-50%, 0)';\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = 'hidden';\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLGlCQUFpQixHQUFHLDJCQUEyQixHQUFHLG9DQUFvQyxHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QjtBQUNuZixjQUFjLG1CQUFPLENBQUMsNENBQU87QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL3V0aWxzLmpzPzdjMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZVRodW1iT3ZlcmxhcCA9IGV4cG9ydHMuYXNzZXJ0VW5yZWFjaGFibGUgPSBleHBvcnRzLnZvaWRGbiA9IGV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZXhwb3J0cy5yZXBsYWNlQXQgPSBleHBvcnRzLnNjaGQgPSBleHBvcnRzLnRyYW5zbGF0ZSA9IGV4cG9ydHMuZ2V0Q2xvc2VzdFRodW1iSW5kZXggPSBleHBvcnRzLnRyYW5zbGF0ZVRodW1icyA9IGV4cG9ydHMuZ2V0UGFkZGluZ0FuZEJvcmRlciA9IGV4cG9ydHMuZ2V0TWFyZ2luID0gZXhwb3J0cy5jaGVja0luaXRpYWxPdmVybGFwID0gZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gZXhwb3J0cy5jaGVja0JvdW5kYXJpZXMgPSBleHBvcnRzLmlzVmVydGljYWwgPSBleHBvcnRzLnJlbGF0aXZlVmFsdWUgPSBleHBvcnRzLm5vcm1hbGl6ZVZhbHVlID0gZXhwb3J0cy5pc1N0ZXBEaXZpc2libGUgPSBleHBvcnRzLmlzVG91Y2hFdmVudCA9IGV4cG9ydHMuZ2V0U3RlcERlY2ltYWxzID0gdm9pZCAwO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIGdldFN0ZXBEZWNpbWFscyA9IGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgdmFyIGRlY2ltYWxzID0gc3RlcC50b1N0cmluZygpLnNwbGl0KCcuJylbMV07XG4gICAgcmV0dXJuIGRlY2ltYWxzID8gZGVjaW1hbHMubGVuZ3RoIDogMDtcbn07XG5leHBvcnRzLmdldFN0ZXBEZWNpbWFscyA9IGdldFN0ZXBEZWNpbWFscztcbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICAgIHJldHVybiAoKGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGgpIHx8XG4gICAgICAgIChldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGgpKTtcbn1cbmV4cG9ydHMuaXNUb3VjaEV2ZW50ID0gaXNUb3VjaEV2ZW50O1xuZnVuY3Rpb24gaXNTdGVwRGl2aXNpYmxlKG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgdmFyIHJlcyA9IChtYXggLSBtaW4pIC8gc3RlcDtcbiAgICB2YXIgcHJlY2lzaW9uID0gODtcbiAgICB2YXIgcm91bmRlZFJlcyA9IE51bWJlcihyZXMudG9GaXhlZChwcmVjaXNpb24pKTtcbiAgICByZXR1cm4gcGFyc2VJbnQocm91bmRlZFJlcy50b1N0cmluZygpLCAxMCkgPT09IHJvdW5kZWRSZXM7XG59XG5leHBvcnRzLmlzU3RlcERpdmlzaWJsZSA9IGlzU3RlcERpdmlzaWJsZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlLCBpbmRleCwgbWluLCBtYXgsIHN0ZXAsIGFsbG93T3ZlcmxhcCwgdmFsdWVzKSB7XG4gICAgdmFyIEJJR19OVU0gPSAxMGUxMDtcbiAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiBCSUdfTlVNKSAvIEJJR19OVU07XG4gICAgaWYgKCFhbGxvd092ZXJsYXApIHtcbiAgICAgICAgdmFyIHByZXYgPSB2YWx1ZXNbaW5kZXggLSAxXTtcbiAgICAgICAgdmFyIG5leHQgPSB2YWx1ZXNbaW5kZXggKyAxXTtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldiA+IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgPCB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpXG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgaWYgKHZhbHVlIDwgbWluKVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIC8vIGByZW1haW5kZXJgIGlzIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBnaXZlbiB2YWx1ZSBhbmQgYSBmdWxsIHN0ZXAgdmFsdWVcbiAgICAvLyB0aGF0IGlzIGNsb3Nlc3QgbG93ZXIgdG8gdGhlIGdpdmVuIHZhbHVlIGFuZCBpcyBpbiB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgbWluIHZhbHVlXG4gICAgLy8gYW5kIHRoZSBnaXZlbiB2YWx1ZVxuICAgIHZhciByZW1haW5kZXIgPSBNYXRoLmZsb29yKHZhbHVlICogQklHX05VTSAtIG1pbiAqIEJJR19OVU0pICVcbiAgICAgICAgTWF0aC5mbG9vcihzdGVwICogQklHX05VTSk7XG4gICAgdmFyIGNsb3Nlc3RMb3dlck51bSA9IE1hdGguZmxvb3IodmFsdWUgKiBCSUdfTlVNIC0gTWF0aC5hYnMocmVtYWluZGVyKSk7XG4gICAgdmFyIHJvdW5kZWQgPSByZW1haW5kZXIgPT09IDAgPyB2YWx1ZSA6IGNsb3Nlc3RMb3dlck51bSAvIEJJR19OVU07XG4gICAgLy8gVmFsdWVzIHdpdGggYSByZW1haW5kZXIgYDwgc3RlcC8yYCBhcmUgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBsb3dlciB2YWx1ZVxuICAgIC8vIHdoaWxlIHZhbHVlcyB3aXRoIGEgcmVtYWluZGVyIGA9ID4gc3RlcC8yYCBhcmUgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBiaWdnZXIgdmFsdWVcbiAgICB2YXIgcmVzID0gTWF0aC5hYnMocmVtYWluZGVyIC8gQklHX05VTSkgPCBzdGVwIC8gMlxuICAgICAgICA/IHJvdW5kZWRcbiAgICAgICAgOiByb3VuZGVkICsgc3RlcDtcbiAgICB2YXIgZGVjaW1hbFBsYWNlcyA9ICgwLCBleHBvcnRzLmdldFN0ZXBEZWNpbWFscykoc3RlcCk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVWYWx1ZSA9IG5vcm1hbGl6ZVZhbHVlO1xuZnVuY3Rpb24gcmVsYXRpdmVWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xufVxuZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gcmVsYXRpdmVWYWx1ZTtcbmZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uVXAgfHwgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duO1xufVxuZXhwb3J0cy5pc1ZlcnRpY2FsID0gaXNWZXJ0aWNhbDtcbmZ1bmN0aW9uIGNoZWNrQm91bmRhcmllcyh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID49IG1heCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm1pbiAoXCIuY29uY2F0KG1pbiwgXCIpIGlzIGVxdWFsL2JpZ2dlciB0aGFuIG1heCAoXCIpLmNvbmNhdChtYXgsIFwiKVwiKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInZhbHVlIChcIi5jb25jYXQodmFsdWUsIFwiKSBpcyBzbWFsbGVyIHRoYW4gbWluIChcIikuY29uY2F0KG1pbiwgXCIpXCIpKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidmFsdWUgKFwiLmNvbmNhdCh2YWx1ZSwgXCIpIGlzIGJpZ2dlciB0aGFuIG1heCAoXCIpLmNvbmNhdChtYXgsIFwiKVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0JvdW5kYXJpZXMgPSBjaGVja0JvdW5kYXJpZXM7XG5mdW5jdGlvbiBjaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAvLyBzZXQgc2VsZWN0ZWRWYWx1ZSB0byBtaW5cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZFZhbHVlIHRvIG1heFxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXM7XG5mdW5jdGlvbiBjaGVja0luaXRpYWxPdmVybGFwKHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWVzLnNsaWNlKDEpLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiB2YWx1ZXNbaV0gPD0gaXRlbTsgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZXM9e1tcIi5jb25jYXQodmFsdWVzLCBcIl19IG5lZWRzIHRvIGJlIHNvcnRlZCB3aGVuIGFsbG93T3ZlcmxhcD17ZmFsc2V9XCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrSW5pdGlhbE92ZXJsYXAgPSBjaGVja0luaXRpYWxPdmVybGFwO1xuZnVuY3Rpb24gZ2V0TWFyZ2luKGVsZW1lbnQpIHtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBhcnNlSW50KHN0eWxlWydtYXJnaW4tdG9wJ10sIDEwKSxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludChzdHlsZVsnbWFyZ2luLWJvdHRvbSddLCAxMCksXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KHN0eWxlWydtYXJnaW4tbGVmdCddLCAxMCksXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZVsnbWFyZ2luLXJpZ2h0J10sIDEwKVxuICAgIH07XG59XG5leHBvcnRzLmdldE1hcmdpbiA9IGdldE1hcmdpbjtcbmZ1bmN0aW9uIGdldFBhZGRpbmdBbmRCb3JkZXIoZWxlbWVudCkge1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcGFyc2VJbnQoc3R5bGVbJ3BhZGRpbmctdG9wJ10sIDEwKSArIHBhcnNlSW50KHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10sIDEwKSxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludChzdHlsZVsncGFkZGluZy1ib3R0b20nXSwgMTApICsgcGFyc2VJbnQoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSwgMTApLFxuICAgICAgICBsZWZ0OiBwYXJzZUludChzdHlsZVsncGFkZGluZy1sZWZ0J10sIDEwKSArIHBhcnNlSW50KHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddLCAxMCksXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZVsncGFkZGluZy1yaWdodCddLCAxMCkgKyBwYXJzZUludChzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10sIDEwKSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRQYWRkaW5nQW5kQm9yZGVyID0gZ2V0UGFkZGluZ0FuZEJvcmRlcjtcbmZ1bmN0aW9uIHRyYW5zbGF0ZVRodW1icyhlbGVtZW50cywgb2Zmc2V0cywgcnRsKSB7XG4gICAgdmFyIGludmVydGVyID0gcnRsID8gLTEgOiAxO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGUoZWxlbWVudCwgaW52ZXJ0ZXIgKiBvZmZzZXRzW2luZGV4XS54LCBvZmZzZXRzW2luZGV4XS55KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudHJhbnNsYXRlVGh1bWJzID0gdHJhbnNsYXRlVGh1bWJzO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgaW5kZXggb2YgdGhlIHRodW1iIHRoYXQgaXMgY2xvc2VzIHRvIGEgZ2l2ZW4gcG9zaXRpb25cbiAqIEBwYXJhbSB0aHVtYnMgLSBhcnJheSBvZiBUaHVtYiBlbGVtZW50IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbVxuICogQHBhcmFtIGNsaWVudFggLSB0YXJnZXQgeCBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gY2xpZW50WSAtIHRhcmdldCB5IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBkaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0cmFja1xuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0VGh1bWJJbmRleCh0aHVtYnMsIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbikge1xuICAgIHZhciB0aHVtYkluZGV4ID0gMDtcbiAgICB2YXIgbWluVGh1bWJEaXN0YW5jZSA9IGdldFRodW1iRGlzdGFuY2UodGh1bWJzWzBdLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGh1bWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aHVtYkRpc3RhbmNlID0gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYnNbaV0sIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbik7XG4gICAgICAgIGlmICh0aHVtYkRpc3RhbmNlIDwgbWluVGh1bWJEaXN0YW5jZSkge1xuICAgICAgICAgICAgbWluVGh1bWJEaXN0YW5jZSA9IHRodW1iRGlzdGFuY2U7XG4gICAgICAgICAgICB0aHVtYkluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGh1bWJJbmRleDtcbn1cbmV4cG9ydHMuZ2V0Q2xvc2VzdFRodW1iSW5kZXggPSBnZXRDbG9zZXN0VGh1bWJJbmRleDtcbmZ1bmN0aW9uIHRyYW5zbGF0ZShlbGVtZW50LCB4LCB5KSB7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoeCwgXCJweCwgXCIpLmNvbmNhdCh5LCBcInB4KVwiKTtcbn1cbmV4cG9ydHMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4cmVhcmRvbi9yYWYtc2NoZFxudmFyIHNjaGQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgICB2YXIgZnJhbWVJZCA9IG51bGw7XG4gICAgdmFyIHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgbGFzdEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB3cmFwcGVyRm47XG59O1xuZXhwb3J0cy5zY2hkID0gc2NoZDtcbmZ1bmN0aW9uIHJlcGxhY2VBdCh2YWx1ZXMsIGluZGV4LCB2YWx1ZSkge1xuICAgIHZhciByZXQgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgcmV0W2luZGV4XSA9IHZhbHVlO1xuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLnJlcGxhY2VBdCA9IHJlcGxhY2VBdDtcbmZ1bmN0aW9uIGdldFRyYWNrQmFja2dyb3VuZChfYSkge1xuICAgIHZhciB2YWx1ZXMgPSBfYS52YWx1ZXMsIGNvbG9ycyA9IF9hLmNvbG9ycywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIF9iID0gX2EuZGlyZWN0aW9uLCBkaXJlY3Rpb24gPSBfYiA9PT0gdm9pZCAwID8gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQgOiBfYiwgX2MgPSBfYS5ydGwsIHJ0bCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgIGlmIChydGwgJiYgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCkge1xuICAgICAgICBkaXJlY3Rpb24gPSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChydGwgJiYgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCkge1xuICAgICAgICBkaXJlY3Rpb24gPSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDtcbiAgICB9XG4gICAgLy8gc29ydCB2YWx1ZXMgYXNjZW5kaW5nXG4gICAgdmFyIHByb2dyZXNzID0gdmFsdWVzLnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pKSAqIDEwMDsgfSk7XG4gICAgdmFyIG1pZGRsZSA9IHByb2dyZXNzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwb2ludCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGFjYywgXCIsIFwiKS5jb25jYXQoY29sb3JzW2luZGV4XSwgXCIgXCIpLmNvbmNhdChwb2ludCwgXCIlLCBcIikuY29uY2F0KGNvbG9yc1tpbmRleCArIDFdLCBcIiBcIikuY29uY2F0KHBvaW50LCBcIiVcIik7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBcImxpbmVhci1ncmFkaWVudChcIi5jb25jYXQoZGlyZWN0aW9uLCBcIiwgXCIpLmNvbmNhdChjb2xvcnNbMF0sIFwiIDAlXCIpLmNvbmNhdChtaWRkbGUsIFwiLCBcIikuY29uY2F0KGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gMV0sIFwiIDEwMCUpXCIpO1xufVxuZXhwb3J0cy5nZXRUcmFja0JhY2tncm91bmQgPSBnZXRUcmFja0JhY2tncm91bmQ7XG5mdW5jdGlvbiB2b2lkRm4oKSB7IH1cbmV4cG9ydHMudm9pZEZuID0gdm9pZEZuO1xuZnVuY3Rpb24gYXNzZXJ0VW5yZWFjaGFibGUoeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRpZG4ndCBleHBlY3QgdG8gZ2V0IGhlcmVcIik7XG59XG5leHBvcnRzLmFzc2VydFVucmVhY2hhYmxlID0gYXNzZXJ0VW5yZWFjaGFibGU7XG4vKipcbiAqIFV0aWwgZnVuY3Rpb24gZm9yIGdyYWJiaW5nIHRoZSB0cnVlIGxhcmdlc3Qgd2lkdGggb2YgYSB0aHVtYlxuICogaW5jbHVkaW5nIHRoZSBsYWJlbFxuICogQHBhcmFtIHRodW1iRWwgLSBUaHVtYiBlbGVtZW50IHRvIGdyYWIgdGhlIGxhcmdlc3Qgd2lkdGggZnJvbVxuICogQHBhcmFtIHZhbHVlIC0gVGh1bWIgdmFsdWUsIG5vdCBsYWJlbCB2YWx1ZVxuICogQHBhcmFtIHNlcGFyYXRvciAtIExhYmVsIHNlcGFyYXRvciB2YWx1ZVxuICovXG52YXIgZ2V0VGh1bWJXaWR0aCA9IGZ1bmN0aW9uICh0aHVtYkVsLCB2YWx1ZSwgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpIHtcbiAgICBpZiAodmFsdWVUb0xhYmVsID09PSB2b2lkIDApIHsgdmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTsgfVxuICAgIHZhciB3aWR0aCA9IE1hdGguY2VpbChfX3NwcmVhZEFycmF5KFt0aHVtYkVsXSwgQXJyYXkuZnJvbSh0aHVtYkVsLmNoaWxkcmVuKSwgdHJ1ZSkucmVkdWNlKGZ1bmN0aW9uICh3aWR0aCwgZWwpIHtcbiAgICAgICAgdmFyIGVsV2lkdGggPSBNYXRoLmNlaWwoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBsYWJlbCBjb250YWlucyBhIG1lcmdlZCBsYWJlbCB2YWx1ZSwgaXQgd29uJ3QgcmV0dXJuIHRoZSB0cnVlXG4gICAgICAgICAqIGxhYmVsIHdpZHRoIGZvciB0aGF0IFRodW1iLiBDbG9uZSB0aGUgbGFiZWwgYW5kIGNoYW5nZSB0aGUgdmFsdWVcbiAgICAgICAgICogdG8gdGhhdCBpbmRpdmlkdWFsIFRodW1iIHZhbHVlIGluIG9yZGVyIHRvIGdyYWIgdGhlIHRydWUgd2lkdGguXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZWwuaW5uZXJUZXh0ICYmXG4gICAgICAgICAgICBlbC5pbm5lclRleHQuaW5jbHVkZXMoc2VwYXJhdG9yKSAmJlxuICAgICAgICAgICAgZWwuY2hpbGRFbGVtZW50Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBlbENsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgZWxDbG9uZS5pbm5lckhUTUwgPSB2YWx1ZVRvTGFiZWwodmFsdWUudG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICBlbENsb25lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxDbG9uZSk7XG4gICAgICAgICAgICBlbFdpZHRoID0gTWF0aC5jZWlsKGVsQ2xvbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbENsb25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxXaWR0aCA+IHdpZHRoID8gZWxXaWR0aCA6IHdpZHRoO1xuICAgIH0sIHRodW1iRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpKTtcbiAgICByZXR1cm4gd2lkdGg7XG59O1xuLyoqXG4gKiBCdWxrIG9mIGxvZ2ljIGZvciB0aHVtYiBvdmVybGFwc1xuICogQ29uc2lkZXIgYSBzY2VuYXJpbyB3aXRoIDUgdGh1bWJzO1xuICogVGh1bWIgMSBvdmVybGFwcyB3aXRoIHRodW1iIDAgYW5kIHRodW1iIDJcbiAqIFRodW1iIDIgb3ZlcmxhcHMgd2l0aCB0aHVtYiAzXG4gKiBXZSBuZWVkIGFuIGFycmF5IHRoYXQgY29udGFpbnMgWzAsIDEsIDIsIDNdXG4gKiBUaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIHRoZSBkaXJlY3RseSBvdmVybGFwcGluZyB0aHVtYnNcbiAqIGFuZCBhbGwgdGh1bWJzIG92ZXJsYXBwaW5nIGxpbmtlZCB0byB0aG9zZSBhbmQgc28gb25cbiAqIEBwYXJhbSBpbmRleCAtIFRodW1iIGluZGV4IGNhbGN1bGF0aW5nIG92ZXJsYXBzIGZvclxuICogQHBhcmFtIG9mZnNldHMgLSBDdXJyZW50IEFycmF5IG9mIFRodW1iIG9mZnNldHMgZm9yIFJhbmdlXG4gKiBAcGFyYW0gdGh1bWJzIC0gQXJyYXkgb2YgVGh1bWIgZWxlbWVudHNcbiAqIEBwYXJhbSB2YWx1ZXMgLSBBcnJheSBvZiBUaHVtYiB2YWx1ZXNcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBTdHJpbmcgc2VwYXJhdG9yIGZvciBtZXJnZWQgbGFiZWwgdmFsdWVzXG4gKiBAcmV0dXJucyBvdmVybGFwcyAtIEFycmF5IG9mIGFsbCBvdmVybGFwcGluZyB0aHVtYnMgZnJvbSB0aGUgaW5kZXhcbiAqL1xudmFyIGdldE92ZXJsYXBzID0gZnVuY3Rpb24gKGluZGV4LCBvZmZzZXRzLCB0aHVtYnMsIHZhbHVlcywgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpIHtcbiAgICBpZiAodmFsdWVUb0xhYmVsID09PSB2b2lkIDApIHsgdmFsdWVUb0xhYmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTsgfVxuICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZSBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgdGhlIG92ZXJsYXBzIEFycmF5XG4gICAgICogSWYgYW4gb3ZlcmxhcCBpcyBmb3VuZCwgZmluZCB0aGUgb3ZlcmxhcHMgZm9yIHRoYXQgb3ZlcmxhcFxuICAgICAqIEBwYXJhbSB0aHVtYkluZGV4IGN1cnJlbnQgVGh1bWIgaW5kZXggdG8gZmluZCBvdmVybGFwcyBmcm9tXG4gICAgICovXG4gICAgdmFyIGJ1aWxkT3ZlcmxhcHMgPSBmdW5jdGlvbiAodGh1bWJJbmRleCkge1xuICAgICAgICB2YXIgdGh1bWJYV2lkdGggPSBnZXRUaHVtYldpZHRoKHRodW1ic1t0aHVtYkluZGV4XSwgdmFsdWVzW3RodW1iSW5kZXhdLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCk7XG4gICAgICAgIHZhciB0aHVtYlggPSBvZmZzZXRzW3RodW1iSW5kZXhdLng7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHRocm91Z2ggdGhlIFRodW1iIG9mZnNldHMsIGlmIHRoZXJlIGlzIGEgbWF0Y2hcbiAgICAgICAgICogYWRkIHRoZSB0aHVtYkluZGV4IGFuZCBzaWJsaW5nSW5kZXggdG8gdGhlIG92ZXJsYXBzIEFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZW4gYnVpbGQgb3ZlcmxhcHMgZnJvbSB0aGUgb3ZlcmxhcHBpbmcgc2libGluZ0luZGV4XG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXRzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBzaWJsaW5nSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nWCA9IF9hLng7XG4gICAgICAgICAgICB2YXIgc2libGluZ1dpZHRoID0gZ2V0VGh1bWJXaWR0aCh0aHVtYnNbc2libGluZ0luZGV4XSwgdmFsdWVzW3NpYmxpbmdJbmRleF0sIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgICAgIGlmICh0aHVtYkluZGV4ICE9PSBzaWJsaW5nSW5kZXggJiZcbiAgICAgICAgICAgICAgICAoKHRodW1iWCA+PSBzaWJsaW5nWCAmJiB0aHVtYlggPD0gc2libGluZ1ggKyBzaWJsaW5nV2lkdGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aHVtYlggKyB0aHVtYlhXaWR0aCA+PSBzaWJsaW5nWCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJYICsgdGh1bWJYV2lkdGggPD0gc2libGluZ1ggKyBzaWJsaW5nV2lkdGgpKSkge1xuICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcHMuaW5jbHVkZXMoc2libGluZ0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5wdXNoKHRodW1iSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcy5wdXNoKHNpYmxpbmdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvdmVybGFwcywgdHJ1ZSksIFt0aHVtYkluZGV4LCBzaWJsaW5nSW5kZXhdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkT3ZlcmxhcHMoc2libGluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYnVpbGRPdmVybGFwcyhpbmRleCk7XG4gICAgLy8gU29ydCBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXMgZnJvbSB0aGUgYnVpbHQgb3ZlcmxhcHNcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KG92ZXJsYXBzLnNvcnQoKSkpO1xufTtcbi8qKlxuICogQSBjdXN0b20gUmVhY3QgSG9vayBmb3IgY2FsY3VsYXRpbmcgd2hldGhlciBhIHRodW1iIG92ZXJsYXBzXG4gKiBhbm90aGVyIGFuZCB3aGV0aGVyIGxhYmVscyBjb3VsZC9zaG91bGQgbWVyZ2UuXG4gKiBAcGFyYW0gcmFuZ2VSZWYgLSBSZWFjdCByZWYgdmFsdWUgb2YgUmFuZ2UgY29tcG9uZW50XG4gKiBAcGFyYW0gdmFsdWVzIC0gY3VycmVudCBSYW5nZSB2YWx1ZXMgQXJyYXlcbiAqIEBwYXJhbSBpbmRleCAtIHRodW1iIGluZGV4XG4gKiBAcGFyYW0gc3RlcCAtIHN0ZXAgdmFsdWUsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBzdHJpbmcgdG8gc2VwYXJhdGUgdGh1bWIgdmFsdWVzXG4gKiBAcmV0dXJucyBsYWJlbCB2YWx1ZSArIHN0eWxpbmcgZm9yIHRodW1iIGxhYmVsXG4gKi9cbnZhciB1c2VUaHVtYk92ZXJsYXAgPSBmdW5jdGlvbiAocmFuZ2VSZWYsIHZhbHVlcywgaW5kZXgsIHN0ZXAsIHNlcGFyYXRvciwgdmFsdWVUb0xhYmVsKSB7XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC4xOyB9XG4gICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IHNlcGFyYXRvciA9ICcgLSAnOyB9XG4gICAgaWYgKHZhbHVlVG9MYWJlbCA9PT0gdm9pZCAwKSB7IHZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07IH1cbiAgICB2YXIgZGVjaW1hbFBsYWNlcyA9ICgwLCBleHBvcnRzLmdldFN0ZXBEZWNpbWFscykoc3RlcCk7XG4gICAgLy8gQ3JlYXRlIGluaXRpYWwgbGFiZWwgc3R5bGUgYW5kIHZhbHVlLiBMYWJlbCB2YWx1ZSBkZWZhdWx0cyB0byB0aHVtYiB2YWx1ZVxuICAgIHZhciBfYSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh7fSksIGxhYmVsU3R5bGUgPSBfYVswXSwgc2V0TGFiZWxTdHlsZSA9IF9hWzFdO1xuICAgIHZhciBfYiA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh2YWx1ZVRvTGFiZWwodmFsdWVzW2luZGV4XS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKSksIGxhYmVsVmFsdWUgPSBfYlswXSwgc2V0TGFiZWxWYWx1ZSA9IF9iWzFdO1xuICAgIC8vIFdoZW4gdGhlIHJhbmdlUmVmIG9yIHZhbHVlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgVGh1bWIgbGFiZWwgdmFsdWVzIGFuZCBzdHlsaW5nXG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyYW5nZVJlZikge1xuICAgICAgICAgICAgdmFyIHRodW1icyA9IHJhbmdlUmVmLmdldFRodW1icygpO1xuICAgICAgICAgICAgaWYgKHRodW1icy5sZW5ndGggPCAxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuZXdTdHlsZSA9IHt9O1xuICAgICAgICAgICAgdmFyIG9mZnNldHNfMSA9IHJhbmdlUmVmLmdldE9mZnNldHMoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGFueSBvdmVybGFwcyBmb3IgdGhlIGdpdmVuIFRodW1iIGluZGV4LiBUaGlzIG11c3QgcmV0dXJuIGFsbCBsaW5rZWRcbiAgICAgICAgICAgICAqIFRodW1icy4gU28gaWYgdGhlcmUgYXJlIDQgVGh1bWJzIGFuZCBUaHVtYnMgMiwgMyBhbmQgNCBvdmVybGFwLiBJZiB3ZSBhcmVcbiAgICAgICAgICAgICAqIGdldHRpbmcgdGhlIG92ZXJsYXBzIGZvciBUaHVtYiAxIGFuZCBpdCBvdmVybGFwcyBvbmx5IFRodW1iIDIsIHdlIG11c3QgZ2V0XG4gICAgICAgICAgICAgKiAyLCAzIGFuZCA0IGFsc28uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBvdmVybGFwcyA9IGdldE92ZXJsYXBzKGluZGV4LCBvZmZzZXRzXzEsIHRodW1icywgdmFsdWVzLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCk7XG4gICAgICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IGxhYmVsIHZhbHVlIG9mIHRoZSBUaHVtYiB2YWx1ZVxuICAgICAgICAgICAgdmFyIGxhYmVsVmFsdWVfMSA9IHZhbHVlVG9MYWJlbCh2YWx1ZXNbaW5kZXhdLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBhcmUgb3ZlcmxhcHMgZm9yIHRoZSBUaHVtYiwgd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3RcbiAgICAgICAgICAgICAqIExhYmVsIHZhbHVlIGFsb25nIHdpdGggdGhlIHJlbGV2YW50IHN0eWxpbmcuIFdlIG9ubHkgd2FudCB0byBzaG93IGEgTGFiZWxcbiAgICAgICAgICAgICAqIGZvciB0aGUgbGVmdCBtb3N0IFRodW1iIGluIGFuIG92ZXJsYXBwaW5nIHNldC5cbiAgICAgICAgICAgICAqIEFsbCBvdGhlciBUaHVtYnMgd2lsbCBiZSBzZXQgdG8gZGlzcGxheTogbm9uZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG92ZXJsYXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldCBhbiBBcnJheSBvZiB0aGUgb2Zmc2V0cyBmb3IgdGhlIG92ZXJsYXBwaW5nIFRodW1ic1xuICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgc28gd2UgY2FuIGRldGVybWluZSBpZiB0aGUgVGh1bWIgd2UgYXJlIGxvb2tpbmcgYXRcbiAgICAgICAgICAgICAgICAgKiBpcyB0aGUgbGVmdCBtb3N0IHRodW1iIGluIGFuIG92ZXJsYXBwaW5nIHNldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRzWCA9IG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbiAoYSwgYywgaSwgcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGEsIHRydWUpLCBbb2Zmc2V0c18xW3NbaV1dLnhdLCBmYWxzZSkgOiBbb2Zmc2V0c18xW3NbaV1dLnhdO1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBvdXIgVGh1bWIgaXMgdGhlIGxlZnQgbW9zdCBUaHVtYiwgd2UgY2FuIGJ1aWxkIGEgTGFiZWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgKiBhbmQgc2V0IHRoZSBzdHlsZSBmb3IgdGhhdCBMYWJlbFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbi5hcHBseShNYXRoLCBvZmZzZXRzWCkgPT09IG9mZnNldHNfMVtpbmRleF0ueCkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRmlyc3QgY2FsY3VsYXRlIHRoZSBMYWJlbCB2YWx1ZS4gVG8gZG8gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICogZ3JhYiBhbGwgdGhlIHZhbHVlcyBmb3IgdGhlIFRodW1icyBpbiBvdXIgb3ZlcmxhcHMuXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZW4gY29udmVydCB0aGF0IHRvIGEgU2V0IGFuZCBzb3J0IGl0IHdoaWxzdCByZW1vdmluZyBkdXBsaWNhdGVzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsVmFsdWVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMuZm9yRWFjaChmdW5jdGlvbiAodGh1bWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsVmFsdWVzXzEucHVzaCh2YWx1ZXNbdGh1bWJdLnRvRml4ZWQoZGVjaW1hbFBsYWNlcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqICBVcGRhdGUgdGhlIGxhYmVsVmFsdWUgd2l0aCB0aGUgcmVzdWx0aW5nIEFycmF5XG4gICAgICAgICAgICAgICAgICAgICAqICBqb2luZWQgYnkgb3VyIGRlZmluZWQgc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFZhbHVlXzEgPSBBcnJheS5mcm9tKG5ldyBTZXQobGFiZWxWYWx1ZXNfMS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBwYXJzZUZsb2F0KGEpIC0gcGFyc2VGbG9hdChiKTsgfSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh2YWx1ZVRvTGFiZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogTGFzdGx5LCBidWlsZCB0aGUgbGFiZWwgc3R5bGluZy4gVGhlIGxhYmVsIHN0eWxpbmcgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgKiBwb3NpdGlvbiB0aGUgbGFiZWwgYW5kIGFwcGx5IGEgdHJhbnNmb3JtIHNvIHRoYXQgaXQncyBjZW50ZXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICogV2Ugd2FudCB0aGUgY2VudGVyIHBvaW50IGJldHdlZW4gdGhlIGxlZnQgZWRnZSBvZiB0aGUgbGVmdCBtb3N0IFRodW1iXG4gICAgICAgICAgICAgICAgICAgICAqIGFuZCB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmlnaHQgbW9zdCBUaHVtYi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG9mZnNldHNYKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBNYXRoLm1heC5hcHBseShNYXRoLCBvZmZzZXRzWCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0V2lkdGggPSB0aHVtYnNbb3ZlcmxhcHNbb2Zmc2V0c1guaW5kZXhPZihsYXN0KV1dLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoTWF0aC5hYnMoZmlyc3QgLSAobGFzdCArIGxhc3RXaWR0aCkpIC8gMiwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtNTAlLCAwKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgVGh1bWIgaXNuJ3QgdGhlIGxlZnQgbW9zdCBUaHVtYiwgaGlkZSB0aGUgTGFiZWwhXG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhYmVsIHZhbHVlIGFuZCBzdHlsZVxuICAgICAgICAgICAgc2V0TGFiZWxWYWx1ZShsYWJlbFZhbHVlXzEpO1xuICAgICAgICAgICAgc2V0TGFiZWxTdHlsZShuZXdTdHlsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbcmFuZ2VSZWYsIHZhbHVlc10pO1xuICAgIHJldHVybiBbbGFiZWxWYWx1ZSwgbGFiZWxTdHlsZV07XG59O1xuZXhwb3J0cy51c2VUaHVtYk92ZXJsYXAgPSB1c2VUaHVtYk92ZXJsYXA7XG4vKipcbiAqIFV0aWwgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBkaXN0YW5jZSBvZiB0aGUgY2VudGVyIG9mIGEgdGh1bWJcbiAqIGZvcm0gYSBnaXZlbiBtb3VzZS90b3VjaCB0YXJnZXQncyBwb3NpdGlvblxuICogQHBhcmFtIHRodW1iRWwgLSBUaHVtYiBlbGVtZW50IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbVxuICogQHBhcmFtIGNsaWVudFggLSB0YXJnZXQgeCBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gY2xpZW50WSAtIHRhcmdldCB5IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBkaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0cmFja1xuICovXG5mdW5jdGlvbiBnZXRUaHVtYkRpc3RhbmNlKHRodW1iRWwsIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbikge1xuICAgIHZhciBfYSA9IHRodW1iRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICByZXR1cm4gaXNWZXJ0aWNhbChkaXJlY3Rpb24pID8gTWF0aC5hYnMoY2xpZW50WSAtICh0b3AgKyBoZWlnaHQgLyAyKSkgOiBNYXRoLmFicyhjbGllbnRYIC0gKGxlZnQgKyB3aWR0aCAvIDIpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-range/lib/utils.js\n"));

/***/ })

});